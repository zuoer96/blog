import{_ as a,o as s,c as e,Q as n}from"./chunks/framework.027d2da0.js";const l="/images/image-20191208091344175.png",p="/images/image-20230918120229386.png",t="/images/image-20230918120235595.png",o="/images/image-20230918120305825.png",i="/images/image-20230918120314490.png",c="/images/image-20230918120322351.png",r="/images/image-20230918120327462.png",g="/images/image-20230918120330919.png",d="/images/image-20230918120355421.png",m="/images/image-20230918120407878.png",h="/images/image-20230918120414572.png",u="/images/image-20230918120419113.png",y="/images/image-20230918120435834.png",b="/images/image-20230918120459691.png",v="/images/image-20230918120504127.png",q="/images/image-20230918120508881.png",T="/images/image-20230918120512921.png",f="/images/image-20230918120528147.png",k="/images/image-20230918120532543.png",P="/images/image-20230918120714310.png",C="/images/image-20230918120720822.png",_="/images/image-20230918120725424.png",x="/images/image-20230918120730858.png",S="/images/image-20230918120735655.png",E="/images/image-20230918120740130.png",I="/images/image-20230918120756944.png",A="/images/image-20230918120800875.png",w="/images/image-20230918120814291.png",L="/images/image-20230918120819709.png",H="/images/image-20230918120824468.png",R="/images/image-20230918120830551.png",B="/images/image-20230918120841684.png",W="/images/image-20230918120928642.png",M="/images/image-20230918120933702.png",j="/images/image-20230918120939050.png",N="/images/image-20230918120949837.png",O="/images/image-20230918120954355.png",V="/images/image-20230918120958616.png",D="/images/image-20230918121002976.png",J="/images/image-20230918121017000.png",z="/images/image-20230918121635986.png",U="/images/image-20230918121642236.png",F="/images/image-20220707094852453.png",G="/images/image-20220707094943533.png",K="/images/image-20220707095221858.png",Z="/images/image-20220707095402196.png",Q="/images/image-20220707095531409.png",X="/images/image-20220707095544595.png",$="/images/image-20220707095641120.png",Y="/images/image-20220707095735224.png",aa="/images/image-20220707100309425.png",sa="/images/image-20220707100327036.png",ea="/images/image-20220707100638150.png",na="/images/image-20220707100739382.png",la="/images/image-20220707100908090.png",pa="/images/image-20220707100937809.png",ta="/images/image-20220707101535636.png",oa="/images/image-20220707101553907.png",ia="/images/image-20220707101650332.png",ca="/images/image-20220707101710136.png",ra="/images/image-20220707101832239.png",ga="/images/image-20220707101838069.png",da="/images/image-20220707101845965.png",ma="/images/image-20220707101856580.png",ha="/images/image-20220707101914213.png",ua="/images/image-20220707101931503.png",ya="/images/image-20220707101959617.png",ba="/images/image-20220707102011869.png",va="/images/image-20220707102025207.png",qa="/images/image-20220707102029146.png",Ta="/images/image-20220707102036811.png",fa="/images/image-20220707102047832.png",ka="/images/image-20220707102230680.png",Pa="/images/image-20220707102351453.png",Ca="/images/image-20220707102444775.png",_a="/images/image-20220707102653576.png",xa="/images/image-20220707102718169.png",Sa="/images/image-20220707102749389.png",Ea="/images/image-20220707102922853.png",Oa=JSON.parse('{"title":"WEB开发介绍","description":"","frontmatter":{"typora-root-url":"./..\\\\..\\\\..\\\\public"},"headers":[],"relativePath":"devops-deploy-tomcat.md","filePath":"docs/05_DevOps/01_部署/01_Tomcat.md"}'),Ia={name:"devops-deploy-tomcat.md"},Aa=n('<h1 id="web开发介绍" tabindex="-1">WEB开发介绍 <a class="header-anchor" href="#web开发介绍" aria-label="Permalink to &quot;WEB开发介绍&quot;">​</a></h1><h2 id="web资源分类-理解" tabindex="-1">WEB资源分类(理解) <a class="header-anchor" href="#web资源分类-理解" aria-label="Permalink to &quot;WEB资源分类(理解)&quot;">​</a></h2><h3 id="什么是web" tabindex="-1">什么是web <a class="header-anchor" href="#什么是web" aria-label="Permalink to &quot;什么是web&quot;">​</a></h3><p>​ WEB，在英语中web即表示网页的意思，它用于<strong>表示Internet主机(服务器)上供外界访问的资源</strong></p><h3 id="web资源分类" tabindex="-1">WEB资源分类 <a class="header-anchor" href="#web资源分类" aria-label="Permalink to &quot;WEB资源分类&quot;">​</a></h3><h4 id="静态资源" tabindex="-1">静态资源 <a class="header-anchor" href="#静态资源" aria-label="Permalink to &quot;静态资源&quot;">​</a></h4><ul><li>web页面中供人们浏览的数据始终是不变 (eg: html,css,js、音视频)</li></ul><h4 id="动态资源" tabindex="-1">动态资源 <a class="header-anchor" href="#动态资源" aria-label="Permalink to &quot;动态资源&quot;">​</a></h4><ul><li>指web页面中供人们浏览的数据是由程序产生的，不同的用户或者不同时间点访问web页面看到的内容各不相同。(eg: servlet,jsp)</li></ul><h3 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h3><ol><li>什么是WEB资源:放在服务器上供客户端访问的资源</li><li>WEB资源的分类: <ol><li>静态资源:WEB页面中共用户访问的数据始终是不变的，比如说:html、css、js、图片、音视频等等</li><li>动态资源:WEB页面中供用户访问的数据是由程序产生的，是会发生变化的，比如Servlet、jsp</li></ol></li></ol><h2 id="软件架构-理解" tabindex="-1">软件架构(理解) <a class="header-anchor" href="#软件架构-理解" aria-label="Permalink to &quot;软件架构(理解)&quot;">​</a></h2><h3 id="架构类别" tabindex="-1">架构类别 <a class="header-anchor" href="#架构类别" aria-label="Permalink to &quot;架构类别&quot;">​</a></h3><h4 id="c-s架构" tabindex="-1">C/S架构 <a class="header-anchor" href="#c-s架构" aria-label="Permalink to &quot;C/S架构&quot;">​</a></h4><p>​ Client / Server,客户端和服务器端，<strong>用户需要安装专门客户端程序。</strong></p><h4 id="b-s架构" tabindex="-1">B/S架构 <a class="header-anchor" href="#b-s架构" aria-label="Permalink to &quot;B/S架构&quot;">​</a></h4><p>​ Browser / Server,浏览器和服务器端，<strong>不需要安装专门客户端程序，浏览器是操作系统内置。</strong></p><h3 id="b-s-和c-s交互模型的比较" tabindex="-1">B/S 和C/S交互模型的比较 <a class="header-anchor" href="#b-s-和c-s交互模型的比较" aria-label="Permalink to &quot;B/S 和C/S交互模型的比较&quot;">​</a></h3><ul><li><p>相同点</p><p>​ 都是基于请求-响应交互模型:即浏览器（客户端) 向 服务器发送 一个 请求。服务器 向 浏览器（客户端）回送 一个 响应 。</p><p>​ 必须先有请求 再有响应</p><p>​ 请求和响应成对出现</p></li><li><p>不同点</p><p>​ 实现C/S模型需要用户在自己的操作系统安装各种客户端软件（百度网盘、腾讯QQ等）；实现B/S模型，只需要用户在操作系统中安装浏览器即可。</p></li></ul><blockquote><p>注：B/S模型可以理解为一种特殊C/S模型。</p></blockquote><h3 id="小结-1" tabindex="-1">小结 <a class="header-anchor" href="#小结-1" aria-label="Permalink to &quot;小结&quot;">​</a></h3><ol><li><p>架构类别</p><ul><li>CS: 客户端-服务器; 必须要安装指定的客户端</li><li>BS: 浏览器-服务器; 不需要安装客户端的, 通过浏览器</li></ul><blockquote><p>我们以BS架构为主.</p></blockquote></li><li><p>Java</p><ul><li>JavaSE java基础</li><li>JavaMe 移动端的,嵌入式</li><li>JavaEE 企业级应用(eg: 网站, 后台系统, 移动端提供数据....)</li></ul></li></ol><h2 id="web通信【重点】" tabindex="-1">web通信【重点】 <a class="header-anchor" href="#web通信【重点】" aria-label="Permalink to &quot;web通信【重点】&quot;">​</a></h2><p>​ 基于http协议,请求响应的机制</p><p>​ 请求一次响应一次</p><p>​ 先有请求后有响应</p><p><img src="'+l+'" alt="image-20191208091344175"></p><h3 id="小结-2" tabindex="-1">小结 <a class="header-anchor" href="#小结-2" aria-label="Permalink to &quot;小结&quot;">​</a></h3><ol><li>浏览器必须先请求服务器, 服务器处理请求, 给浏览器响应</li><li>一次请求, 一次响应</li><li>先有请求,再有响应</li><li>请求响应基于<strong>HTTP协议</strong></li></ol><h1 id="服务器" tabindex="-1">服务器 <a class="header-anchor" href="#服务器" aria-label="Permalink to &quot;服务器&quot;">​</a></h1><p>processon的画图软件的注册地址:</p><p><a href="https://www.processon.com/i/5f0440b81e085326375eb062" target="_blank" rel="noreferrer">https://www.processon.com/i/5f0440b81e085326375eb062</a></p><h2 id="服务器介绍" tabindex="-1">服务器介绍 <a class="header-anchor" href="#服务器介绍" aria-label="Permalink to &quot;服务器介绍&quot;">​</a></h2><h3 id="什么是服务器" tabindex="-1">什么是服务器 <a class="header-anchor" href="#什么是服务器" aria-label="Permalink to &quot;什么是服务器&quot;">​</a></h3><p>​ 服务器就是一个软件，任何电脑只需要安装上了服务器软件， 我们的电脑就可以当做一台服务器了.</p><p>​ 服务器: 硬件(电脑)+软件(mysql, tomcat,nginx)</p><h3 id="常见web服务器" tabindex="-1">常见web服务器 <a class="header-anchor" href="#常见web服务器" aria-label="Permalink to &quot;常见web服务器&quot;">​</a></h3><ul><li><p>WebLogic</p><p>​ Oracle公司的产品，是目前应用比较多的Web服务器，支持J2EE规范。WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。</p><p><img src="'+p+'" alt="image-20230918120229386"></p></li><li><p>WebSphere</p><p>​ IBM公司的WebSphere，支持JavaEE规范。WebSphere 是随需应变的电子商务时代的最主要的软件平台，可用于企业开发、部署和整合新一代的电子商务应用。</p><p><img src="'+t+'" alt="image-20230918120235595"></p></li><li><p>Glass Fish</p><p>​ 最早是Sun公司的产品，后来被Oracle收购，开源免费，中型服务器。</p></li><li><p>JBoss</p><p>​ JBoss公司产品，开源，支持JavaEE规范，占用内存、硬盘小，安全性和性能高。</p><p><img src="'+o+'" alt="image-20230918120305825"></p></li><li><p>Tomcat</p><p>​ 中小型的应用系统，免费,开源,效率特别高, 适合扩展(搭集群)支持JSP和Servlet.</p><p><img src="'+i+'" alt="image-20230918120314490"></p></li></ul><h2 id="tomcat7-快速部署" tabindex="-1">Tomcat7 快速部署 <a class="header-anchor" href="#tomcat7-快速部署" aria-label="Permalink to &quot;Tomcat7 快速部署&quot;">​</a></h2><p>1.解压 apache-tomcat-7.0.78-windows-x64.zip 到非中文无空格目录中</p><p>2.检查是否配置了 JAVA_HOME</p><p><img src="'+c+'" alt="image-20230918120322351"></p><p>3.新建环境变量 CATALINA_HOME=解压目录</p><p><img src="'+r+'" alt="image-20230918120327462"></p><p>4.在 Path 环境变量中加入 Tomcat 解压目录\\bin 目录</p><p><img src="'+g+'" alt="image-20230918120330919"></p><p>5.在命令行中运行 catalina run 启动 Tomcat 服务器，在浏览器地址栏访问如下地址进行测试: <code>http://localhost:8080</code></p><p><img src="'+d+'" alt="image-20230918120355421"></p><p>6.如果启动失败，提示端口号被占用，则将默认的 8080 端口修改为其他未使用的值，例如 8989 等。</p><p>打开：<code>解压目录\\\\conf\\\\server.xml</code>，找到第一个 Connector 标签，修改 port属性</p><p>7.在 Eclipse 中创建 Tomcat 镜像</p><p><img src="'+m+'" alt="image-20230918120407878"></p><p><img src="'+h+'" alt="image-20230918120414572"></p><p><img src="'+u+`" alt="image-20230918120419113"></p><p>8.创建动态 Web 工程进行测试</p><p>[1]在 WebContent 目录下创建 index.jsp，加入如下代码</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">&lt;%@page import=&quot;java.util.Date&quot;%&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">&lt;%=new Date() %&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">&lt;%@page import=&quot;java.util.Date&quot;%&gt;</span></span>
<span class="line"><span style="color:#24292e;">&lt;%=new Date() %&gt;</span></span></code></pre></div><p>[2]在 index.jsp 上点右键：Run as→Run on Server 查看运行结果</p><p>9.说明：关联 Tomcat 镜像时，Eclipse 会从本地 Tomcat 中复制信息及文件，之后二者的配置信息就没有关系了，其中任何一个的配置信息发生变化都不会自动同步到另外一个。</p><p><img src="`+y+'" alt="image-20230918120435834"></p><h2 id="tomcat8-安装和使用" tabindex="-1">tomcat8 安装和使用 <a class="header-anchor" href="#tomcat8-安装和使用" aria-label="Permalink to &quot;tomcat8 安装和使用&quot;">​</a></h2><h3 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to &quot;概述&quot;">​</a></h3><p>​ Tomcat服务器是一个免费的开放源代码的Web应用服务器。</p><p>​ Tomcat是Apache软件基金会（Apache Software Foundation）的Jakarta项目中的一个核心项目，由Apache、Sun和其他一些公司及个人共同开发而成。由于有了Sun的参与和支持，最新的Servlet 和JSP规范总是能在Tomcat中得到体现。</p><p>​ 因为Tomcat技术先进、性能稳定，而且免费，因而深受Java爱好者的喜爱并得到了部分软件开发商的认可，是目前比较流行的Web应用服务器。</p><p>​ Tomcat安装分为解压版和安装版，这里着重介绍解压版。当然，我们在安装Tomcat前都应该将jdk安装好且配置好环境变量。Apache Tomcat 8.5需要一个Java标准版运行时环境(JRE)版本7或更高版本。</p><h3 id="tomcat的下载" tabindex="-1">tomcat的下载 <a class="header-anchor" href="#tomcat的下载" aria-label="Permalink to &quot;tomcat的下载&quot;">​</a></h3><p>强调: 我们使用的软件版本，要和老师用的版本一致</p><p>目前阶段: jdk8、mysql5、tomcat8</p><ol><li><p>**先去官网下载：<a href="http://tomcat.apache.org/%EF%BC%8C%E9%80%89%E6%8B%A9tomcat8%E7%89%88%E6%9C%AC(%E8%B5%84%E6%96%99%E5%B7%B2%E6%8F%90%E4%BE%9B)%EF%BC%88%E7%BA%A2%E6%A1%86%E6%89%80%E7%A4%BA%EF%BC%89**%EF%BC%9A" target="_blank" rel="noreferrer">http://tomcat.apache.org/，选择tomcat8版本(资料已提供)（红框所示）**：</a></p><p><img src="'+b+'" alt="image-20230918120459691"></p></li><li><p>选择要下载的文件（红框所示）：</p><p><img src="'+v+'" alt="image-20230918120504127"></p><p>tar.gz 文件 是linux操作系统下的安装版本</p><p>exe文件是window操作系统下的安装版本</p><p>zip文件是window操作系统下压缩版本（我们选择zip文件）</p></li><li><p><strong>下载完成</strong>：</p></li></ol><p><img src="'+q+'" alt="image-20230918120508881"></p><h3 id="tomcat服务器软件安装" tabindex="-1">tomcat服务器软件安装 <a class="header-anchor" href="#tomcat服务器软件安装" aria-label="Permalink to &quot;tomcat服务器软件安装&quot;">​</a></h3><ol><li><p>直接解压当前这个tomcat压缩包：(<strong>不要有中文,不要有空格</strong>)</p></li><li><p>配置环境变量：</p><p>tomcat运行依赖于java环境： <img src="'+T+'" alt="image-20230918120512921"></p></li></ol><p>也可以配置环境变量 CATALINA_HOME 和 Path</p><p>​ 系统变量增加: CATALINA_HOME D:\\develop\\tomcat\\apache-tomcat-8.5.55</p><p>​ path增加: <code>%CATALINA_HOME%\\bin</code></p><p>​</p><h3 id="tomcat的目录结构" tabindex="-1">tomcat的目录结构 <a class="header-anchor" href="#tomcat的目录结构" aria-label="Permalink to &quot;tomcat的目录结构&quot;">​</a></h3><p><img src="'+f+'" alt="image-20230918120528147"></p><h3 id="启动tocmat" tabindex="-1">启动Tocmat <a class="header-anchor" href="#启动tocmat" aria-label="Permalink to &quot;启动Tocmat&quot;">​</a></h3><p>通过以上安装，Tomcat启动方式就有很多种了：</p><ol><li><p>查找tomcat目录下bin目录，查找其中的startup.bat命令，双击启动服务器： <img src="'+k+'" alt="image-20230918120532543"></p><p>启动效果： <img src="'+P+'" alt="image-20230918120714310"></p></li></ol><p>2.在Tomcat解压目录中的bin文件夹下，找到tomcat8.exe并双击启动。</p><p><img src="'+C+'" alt="image-20230918120720822"></p><p>3.在Tomcat解压目录中的bin文件夹下，找到tomcat8w.exe并双击启动。</p><p><img src="'+_+'" alt="image-20230918120725424"></p><p>在图形界面中点击 Start 按钮启动。</p><p><img src="'+x+'" alt="image-20230918120730858"></p><p>4.在CMD命令行中输入startup回车启动Tomcat。</p><p><img src="'+S+'" alt="image-20230918120735655"></p><p>5.在Windows系统服务中找到Tomcat服务进行启动。</p><p><img src="'+E+'" alt="image-20230918120740130"></p><h3 id="测试tomcat" tabindex="-1">测试Tomcat <a class="header-anchor" href="#测试tomcat" aria-label="Permalink to &quot;测试Tomcat&quot;">​</a></h3><p>打开浏览器在，在浏览器的地址栏中输入：</p><p><code>http://127.0.0.1:8080或者http://localhost:8080</code></p><p><img src="'+I+'" alt="image-20230918120756944"></p><p>注： Localhost相当于127.0.0.1</p><h3 id="关闭tomcat" tabindex="-1">关闭Tomcat <a class="header-anchor" href="#关闭tomcat" aria-label="Permalink to &quot;关闭Tomcat&quot;">​</a></h3><p>查找tomcat目录下bin目录，查找其中的shutdown.bat命令，双击关闭服务器： <img src="'+A+`" alt="image-20230918120800875"></p><h3 id="常见问题" tabindex="-1">常见问题 <a class="header-anchor" href="#常见问题" aria-label="Permalink to &quot;常见问题&quot;">​</a></h3><h4 id="安装注意点" tabindex="-1">安装注意点 <a class="header-anchor" href="#安装注意点" aria-label="Permalink to &quot;安装注意点&quot;">​</a></h4><ul><li>解压到一个==没有中文和空格==目录下</li><li>使用之前, 配置java_home和path(jdk环境变量) <ul><li>java_home 不要配到bin目录,配到jdk的安装目录</li><li>path 才是配到bin目录</li></ul></li></ul><h4 id="一台服务器无法显示2个tomcat" tabindex="-1">一台服务器无法显示2个tomcat <a class="header-anchor" href="#一台服务器无法显示2个tomcat" aria-label="Permalink to &quot;一台服务器无法显示2个tomcat&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">/bin/start.bat 26行,修改 start 为 run</span></span>
<span class="line"><span style="color:#e1e4e8;">因为端口占用过了</span></span>
<span class="line"><span style="color:#e1e4e8;">将server.xml 8005,8443,8080等端口修改为9005,9443,9080.</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">/bin/start.bat 26行,修改 start 为 run</span></span>
<span class="line"><span style="color:#24292e;">因为端口占用过了</span></span>
<span class="line"><span style="color:#24292e;">将server.xml 8005,8443,8080等端口修改为9005,9443,9080.</span></span></code></pre></div><h4 id="端口号冲突" tabindex="-1">端口号冲突 <a class="header-anchor" href="#端口号冲突" aria-label="Permalink to &quot;端口号冲突&quot;">​</a></h4><p>​ 报如下异常: java.net.BindException: Address already in use: JVM_Bind 8080</p><p>​ 解决办法:</p><p>​ 第一种:修改Tomcat的端口号</p><p>​ <img src="`+w+'" alt="image-20230918120814291"></p><p>​ 修改conf/server.xml , 第70行左右</p><p><img src="'+L+'" alt="image-20230918120819709"></p><p>第二种:查询出来哪一个进程把8080占用了, 结束掉占用8080端口后的程序</p><p>​ 打开命令行输入: netstat -ano</p><p>​ 找到占用了8080 端口的 进程的id</p><p>​ 去任务管理器kill掉这个id对应的程序</p><p>​ <img src="'+H+'" alt="image-20230918120824468"></p><p>​</p><h4 id="java-home没有配置" tabindex="-1">JAVA_HOME没有配置 <a class="header-anchor" href="#java-home没有配置" aria-label="Permalink to &quot;JAVA_HOME没有配置&quot;">​</a></h4><ul><li>会出现闪退 (如果java_home配置了还是闪退 忽略它了, 后面在IDEA里面进行启动, 就没有这个问题)</li></ul><h4 id="tomcat-8-5-控制台中文乱码问题" tabindex="-1">tomcat 8.5 控制台中文乱码问题 <a class="header-anchor" href="#tomcat-8-5-控制台中文乱码问题" aria-label="Permalink to &quot;tomcat 8.5 控制台中文乱码问题&quot;">​</a></h4><p>新装的,启动乱码,不影响,但是体验不好</p><p><img src="'+R+'" alt="image-20230918120830551"></p><p>本质原因就一个：<strong>字节流解码为字符串时，使用了错误的字符集（和编码所用字符集不一致）！</strong></p><p>因为windows系统中，其命令行窗口在解码字节数组时，默认使用本地字符集（对于我们就是GBK），而tomcat默认输出的启动信息是通过utf8进行编码的，这就导致编码与解码所使用字符集的不一致，从而出现了乱码情况！</p><p><img src="'+B+'" alt="image-20230918120841684"></p><h5 id="解决方案1" tabindex="-1">解决方案1 <a class="header-anchor" href="#解决方案1" aria-label="Permalink to &quot;解决方案1&quot;">​</a></h5><p>conf/logging.properties，将 UTF-8 修改为 GBK</p><p>java.util.logging.ConsoleHandler.encoding = <strong>GBK</strong></p><p><strong>要改的话,其他几个都改了</strong></p><h5 id="解决方案2" tabindex="-1">解决方案2 <a class="header-anchor" href="#解决方案2" aria-label="Permalink to &quot;解决方案2&quot;">​</a></h5><p>修改console窗口为UTF-8格式</p><p>2个我都不改...tomcat就临时用下,后面内嵌使用.懒得改了</p><h3 id="总结说明" tabindex="-1">总结说明 <a class="header-anchor" href="#总结说明" aria-label="Permalink to &quot;总结说明&quot;">​</a></h3><p>1.配置JDK环境变量名为JAVA_HOME，Tomcat会找JAVA_HOME环境变量来定位JDK。</p><p>2.同样Tomcat环境变量名为CATALINA_HOME，Tomcat启动时会找CATALINA_HOME环境变量，来调用startup.bat。</p><p>3.Tomcat配置环境变量主要是为了在CMD命令行可以直接输入Tomcat脚本命令，这样不用定位到安装目录的bin文件夹下。</p><p>4.Tomcat安装版要比解压版省事儿，一些工作安装版完成了。</p><p>5.需要注意Tomcat对java版本要求。</p><h2 id="tomcat服务注册" tabindex="-1">Tomcat服务注册 <a class="header-anchor" href="#tomcat服务注册" aria-label="Permalink to &quot;Tomcat服务注册&quot;">​</a></h2><p>由于上面配置了Tomcat的环境变量，所以现在可以在CMD命令行中直接输入bin中的命令脚本。服务器注册输入 <strong>service install</strong>回车。</p><p><img src="'+W+'" alt="image-20230918120928642"></p><p>在 服务 中我们便看到了 Apache Tomcat8.5服务，可以在其属性中设置为 自启。一般项目部署实施需要进行设置，这样服务器重启后Tomcat便可自行启动。</p><p><img src="'+M+'" alt="image-20230918120933702"></p><p>Tomcat服务移除：<strong>service remove</strong></p><p><img src="'+j+`" alt="image-20230918120939050"></p><h2 id="运用tomcat服务器部署web项目" tabindex="-1">运用Tomcat服务器部署WEB项目 <a class="header-anchor" href="#运用tomcat服务器部署web项目" aria-label="Permalink to &quot;运用Tomcat服务器部署WEB项目&quot;">​</a></h2><h3 id="标准的javaweb应用目录结构" tabindex="-1">标准的JavaWeb应用目录结构 <a class="header-anchor" href="#标准的javaweb应用目录结构" aria-label="Permalink to &quot;标准的JavaWeb应用目录结构&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">WebAPP(文件夹,项目)  </span></span>
<span class="line"><span style="color:#e1e4e8;">   		|---静态资源: html,css,js,图片(它们可以以文件存在,也可以以文件夹存在)  </span></span>
<span class="line"><span style="color:#e1e4e8;">   		|---WEB-INF 固定写法。此目录下的文件不能被外部(浏览器)直接访问</span></span>
<span class="line"><span style="color:#e1e4e8;">   			|---lib:jar包存放的目录</span></span>
<span class="line"><span style="color:#e1e4e8;">   			|---web.xml:当前项目的配置文件(3.0规范之后可以省略)</span></span>
<span class="line"><span style="color:#e1e4e8;">   			|---classes:java类编译后生成class文件存放的路径</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">WebAPP(文件夹,项目)  </span></span>
<span class="line"><span style="color:#24292e;">   		|---静态资源: html,css,js,图片(它们可以以文件存在,也可以以文件夹存在)  </span></span>
<span class="line"><span style="color:#24292e;">   		|---WEB-INF 固定写法。此目录下的文件不能被外部(浏览器)直接访问</span></span>
<span class="line"><span style="color:#24292e;">   			|---lib:jar包存放的目录</span></span>
<span class="line"><span style="color:#24292e;">   			|---web.xml:当前项目的配置文件(3.0规范之后可以省略)</span></span>
<span class="line"><span style="color:#24292e;">   			|---classes:java类编译后生成class文件存放的路径</span></span></code></pre></div><h3 id="发布项目到tomcat" tabindex="-1">发布项目到tomcat <a class="header-anchor" href="#发布项目到tomcat" aria-label="Permalink to &quot;发布项目到tomcat&quot;">​</a></h3><h4 id="直接发布" tabindex="-1">直接发布 <a class="header-anchor" href="#直接发布" aria-label="Permalink to &quot;直接发布&quot;">​</a></h4><p>​ 只要将准备好的web资源直接复制到tomcat/webapps文件夹下，就可以通过浏览器使用http协议访问获取</p><h4 id="虚拟路径的方式发布项目" tabindex="-1">虚拟路径的方式发布项目 <a class="header-anchor" href="#虚拟路径的方式发布项目" aria-label="Permalink to &quot;虚拟路径的方式发布项目&quot;">​</a></h4><ol><li>第一步：在tomcat/conf目录下新建一个Catalina目录（如果已经存在无需创建）</li></ol><p><img src="`+N+'" alt="image-20230918120949837"></p><ol start="2"><li>第二步：在Catalina目录下创建localhost目录（如果已经存在无需创建）</li></ol><p><img src="'+O+'" alt="image-20230918120954355"></p><ol start="3"><li>第三步：在localhost中创建xml配置文件，名称为：随便写，比如叫做second.xml（注：这个名称是浏览器访问路径）</li></ol><p><img src="'+V+`" alt="image-20230918120958616"></p><ol start="4"><li><p>第四步：添加second.xml文件的内容为： docBase就是你需要作为虚拟路径的项目的路径</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">&lt;?xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;?&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">&lt;Context docBase=&quot;C:\\JavaEE_Relation\\JavaEE101\\itheima101_staticWeb\\day24_html&quot; /&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">&lt;?xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;?&gt;</span></span>
<span class="line"><span style="color:#24292e;">&lt;Context docBase=&quot;C:\\JavaEE_Relation\\JavaEE101\\itheima101_staticWeb\\day24_html&quot; /&gt;</span></span></code></pre></div><p><img src="`+D+'" alt="image-20230918121002976"></p></li><li><p>第五步：直接访问(通过写配置文件的路径来访问):</p><p><code>http://localhost:8080/second/a.html</code>(second就是配置文件的名字, 映射成了myApp)</p></li></ol><h1 id="http协议" tabindex="-1">http协议 <a class="header-anchor" href="#http协议" aria-label="Permalink to &quot;http协议&quot;">​</a></h1><h2 id="http协议概述" tabindex="-1">http协议概述 <a class="header-anchor" href="#http协议概述" aria-label="Permalink to &quot;http协议概述&quot;">​</a></h2><h3 id="什么是http协议" tabindex="-1">什么是HTTP协议 <a class="header-anchor" href="#什么是http协议" aria-label="Permalink to &quot;什么是HTTP协议&quot;">​</a></h3><p>​ HTTP是HyperText Transfer Protocol(超文本传输协议)的简写，传输HTML文件。</p><p>​ HTTP是互联网上用的最多的一个协议, 所有的www开头的都是遵循这个协议的(可能是https)</p><h3 id="http协议的作用" tabindex="-1">HTTP协议的作用 <a class="header-anchor" href="#http协议的作用" aria-label="Permalink to &quot;HTTP协议的作用&quot;">​</a></h3><p>​ HTTP作用：用于定义WEB浏览器与WEB服务器之间<strong>交换数据的过程</strong>和数据本身的<strong>内容</strong></p><p>​ 浏览器和服务器交互过程: 浏览器请求, 服务请求响应</p><p>​ 请求(请求行,请求头,请求体)</p><p>​ 响应(响应行,响应头,响应体)</p><h3 id="小结-3" tabindex="-1">小结 <a class="header-anchor" href="#小结-3" aria-label="Permalink to &quot;小结&quot;">​</a></h3><ol><li><p>HTTP协议:超文本传输协议，它就定义了客户端与服务器端进行交互时候的规则</p></li><li><p>HTTP协议的作用:定义客户端与服务器端交互的过程以及传输的数据</p></li></ol><h2 id="请求部分-了解" tabindex="-1">请求部分(了解) <a class="header-anchor" href="#请求部分-了解" aria-label="Permalink to &quot;请求部分(了解)&quot;">​</a></h2><p><img src="'+J+`" alt="image-20230918121017000"></p><ul><li>get方式请求</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">【请求行】</span></span>
<span class="line"><span style="color:#e1e4e8;">GET /myApp/success.html?username=zs&amp;password=123456 HTTP/1.1</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">【请求头】</span></span>
<span class="line"><span style="color:#e1e4e8;">Accept: text/html, application/xhtml+xml, */*</span></span>
<span class="line"><span style="color:#e1e4e8;">X-HttpWatch-RID: 41723-10011</span></span>
<span class="line"><span style="color:#e1e4e8;">Referer: http://localhost:8080/myApp/login.html</span></span>
<span class="line"><span style="color:#e1e4e8;">Accept-Language: zh-Hans-CN,zh-Hans;q=0.5</span></span>
<span class="line"><span style="color:#e1e4e8;">User-Agent: Mozilla/5.0 (MSIE 9.0; qdesk 2.4.1266.203; Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like Gecko</span></span>
<span class="line"><span style="color:#e1e4e8;">Accept-Encoding: gzip, deflate</span></span>
<span class="line"><span style="color:#e1e4e8;">Host: localhost:8080</span></span>
<span class="line"><span style="color:#e1e4e8;">Connection: Keep-Alive</span></span>
<span class="line"><span style="color:#e1e4e8;">Cookie: Idea-b77ddca6=4bc282fe-febf-4fd1-b6c9-72e9e0f381e8</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">【请求行】</span></span>
<span class="line"><span style="color:#24292e;">GET /myApp/success.html?username=zs&amp;password=123456 HTTP/1.1</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">【请求头】</span></span>
<span class="line"><span style="color:#24292e;">Accept: text/html, application/xhtml+xml, */*</span></span>
<span class="line"><span style="color:#24292e;">X-HttpWatch-RID: 41723-10011</span></span>
<span class="line"><span style="color:#24292e;">Referer: http://localhost:8080/myApp/login.html</span></span>
<span class="line"><span style="color:#24292e;">Accept-Language: zh-Hans-CN,zh-Hans;q=0.5</span></span>
<span class="line"><span style="color:#24292e;">User-Agent: Mozilla/5.0 (MSIE 9.0; qdesk 2.4.1266.203; Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like Gecko</span></span>
<span class="line"><span style="color:#24292e;">Accept-Encoding: gzip, deflate</span></span>
<span class="line"><span style="color:#24292e;">Host: localhost:8080</span></span>
<span class="line"><span style="color:#24292e;">Connection: Keep-Alive</span></span>
<span class="line"><span style="color:#24292e;">Cookie: Idea-b77ddca6=4bc282fe-febf-4fd1-b6c9-72e9e0f381e8</span></span></code></pre></div><ul><li>post请求</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">【请求行】</span></span>
<span class="line"><span style="color:#e1e4e8;">POST /myApp/success.html HTTP/1.1</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">【请求头】</span></span>
<span class="line"><span style="color:#e1e4e8;">Accept: text/html, application/xhtml+xml, */*</span></span>
<span class="line"><span style="color:#e1e4e8;">X-HttpWatch-RID: 37569-10012</span></span>
<span class="line"><span style="color:#e1e4e8;">Referer: http://localhost:8080/myApp/login.html</span></span>
<span class="line"><span style="color:#e1e4e8;">Accept-Language: zh-Hans-CN,zh-Hans;q=0.5</span></span>
<span class="line"><span style="color:#e1e4e8;">User-Agent: Mozilla/5.0 (MSIE 9.0; qdesk 2.4.1266.203; Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like Gecko</span></span>
<span class="line"><span style="color:#e1e4e8;">Content-Type: application/x-www-form-urlencoded</span></span>
<span class="line"><span style="color:#e1e4e8;">Accept-Encoding: gzip, deflate</span></span>
<span class="line"><span style="color:#e1e4e8;">Host: localhost:8080</span></span>
<span class="line"><span style="color:#e1e4e8;">Content-Length: 27</span></span>
<span class="line"><span style="color:#e1e4e8;">Connection: Keep-Alive</span></span>
<span class="line"><span style="color:#e1e4e8;">Cache-Control: no-cache</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">【请求体】</span></span>
<span class="line"><span style="color:#e1e4e8;">username=zs&amp;password=123456</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">【请求行】</span></span>
<span class="line"><span style="color:#24292e;">POST /myApp/success.html HTTP/1.1</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">【请求头】</span></span>
<span class="line"><span style="color:#24292e;">Accept: text/html, application/xhtml+xml, */*</span></span>
<span class="line"><span style="color:#24292e;">X-HttpWatch-RID: 37569-10012</span></span>
<span class="line"><span style="color:#24292e;">Referer: http://localhost:8080/myApp/login.html</span></span>
<span class="line"><span style="color:#24292e;">Accept-Language: zh-Hans-CN,zh-Hans;q=0.5</span></span>
<span class="line"><span style="color:#24292e;">User-Agent: Mozilla/5.0 (MSIE 9.0; qdesk 2.4.1266.203; Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like Gecko</span></span>
<span class="line"><span style="color:#24292e;">Content-Type: application/x-www-form-urlencoded</span></span>
<span class="line"><span style="color:#24292e;">Accept-Encoding: gzip, deflate</span></span>
<span class="line"><span style="color:#24292e;">Host: localhost:8080</span></span>
<span class="line"><span style="color:#24292e;">Content-Length: 27</span></span>
<span class="line"><span style="color:#24292e;">Connection: Keep-Alive</span></span>
<span class="line"><span style="color:#24292e;">Cache-Control: no-cache</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">【请求体】</span></span>
<span class="line"><span style="color:#24292e;">username=zs&amp;password=123456</span></span></code></pre></div><h3 id="请求行" tabindex="-1">请求行 <a class="header-anchor" href="#请求行" aria-label="Permalink to &quot;请求行&quot;">​</a></h3><ul><li>请求行</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">GET  /myApp/success.html?username=zs&amp;password=123456 HTTP/1.1	</span></span>
<span class="line"><span style="color:#e1e4e8;">POST /myApp/success.html HTTP/1.1</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">GET  /myApp/success.html?username=zs&amp;password=123456 HTTP/1.1	</span></span>
<span class="line"><span style="color:#24292e;">POST /myApp/success.html HTTP/1.1</span></span></code></pre></div><ul><li><p>请求方式(8种,put,delete等)</p><p>​ GET:明文传输, 不安全,参数跟在请求路径后面,对请求参数大小有限制,</p><p>​ POST: 暗文传输,安全一些,请求参数在请求体里,对请求参数大小没有有限制,</p></li><li><p>URI:统一资源标识符（即：去掉协议和IP地址部分）</p></li><li><p>协议版本:HTTP/1.1</p></li></ul><h3 id="请求头" tabindex="-1">请求头 <a class="header-anchor" href="#请求头" aria-label="Permalink to &quot;请求头&quot;">​</a></h3><p>​ 从第2行到空行处，都叫请求头,以键值对的形式存在,但存在一个key对应多个值的请求头.</p><p>​ <strong>作用:浏览器告诉服务器自己相关的设置.</strong></p><ul><li>Accept:浏览器可接受的MIME类型 ,告诉服务器客户端能接收什么样类型的文件。</li><li><strong>User-Agent</strong>:浏览器信息.(浏览器类型, 浏览器的版本....)</li><li>Accept-Charset: 浏览器通过这个头告诉服务器，它支持哪种字符集</li><li>Content-Length:表示请求参数的长度</li><li>Host:初始URL中的主机和端口</li><li><strong>Referrer</strong>:从哪里里来的(之前是哪个资源)、防盗链</li><li><strong>Content-Type</strong>:内容类型,告诉服务器,浏览器传输数据的MIME类型，文件传输的类型,application/x-www-form-urlencoded .</li><li>Accept-Encoding:浏览器能够进行解码的数据编码方式，比如gzip</li><li>Connection:表示是否需要持久连接。如果服务器看到这里的值为“Keep -Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接 )</li><li><strong>Cookie</strong>:这是最重要的请求头信息之一(会话技术, 后面会有专门的时间来讲的)</li><li>Date：Date: Mon, 22Aug 2011 01:55:39 GMT请求时间GMT</li></ul><h3 id="请求体" tabindex="-1">请求体 <a class="header-anchor" href="#请求体" aria-label="Permalink to &quot;请求体&quot;">​</a></h3><p>​ 只有请求方式是post的时候,才有请求体. 即post请求时,请求参数(提交的数据)所在的位置</p><h3 id="小结-4" tabindex="-1">小结 <a class="header-anchor" href="#小结-4" aria-label="Permalink to &quot;小结&quot;">​</a></h3><pre><code>1. 请求行
  	   	1. 请求方式
  	   	2. 请求路径
2. 请求头: 它是由键值对构成
3. 请求体: 只有post请求才有请求体，post请求的请求体是用于携带请求参数的
</code></pre><h2 id="响应部分-了解" tabindex="-1">响应部分(了解) <a class="header-anchor" href="#响应部分-了解" aria-label="Permalink to &quot;响应部分(了解)&quot;">​</a></h2><p><img src="`+z+`" alt="image-20230918121635986"></p><ul><li><p>响应部分</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">【响应行】</span></span>
<span class="line"><span style="color:#e1e4e8;">HTTP/1.1 200 OK</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">【响应头】</span></span>
<span class="line"><span style="color:#e1e4e8;">Accept-Ranges: bytes</span></span>
<span class="line"><span style="color:#e1e4e8;">ETag: W/&quot;143-1557909081579&quot;</span></span>
<span class="line"><span style="color:#e1e4e8;">Last-Modified: Wed, 15 May 2019 08:31:21 GMT</span></span>
<span class="line"><span style="color:#e1e4e8;">Content-Type: text/html</span></span>
<span class="line"><span style="color:#e1e4e8;">Content-Length: 143</span></span>
<span class="line"><span style="color:#e1e4e8;">Date: Sun, 08 Dec 2019 02:20:04 GMT</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">【响应体】</span></span>
<span class="line"><span style="color:#e1e4e8;">&lt;!DOCTYPE html&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">&lt;html lang=&quot;en&quot;&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">&lt;head&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">    &lt;title&gt;Title&lt;/title&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">&lt;/head&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">&lt;body&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">    Success</span></span>
<span class="line"><span style="color:#e1e4e8;">&lt;/body&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">&lt;/html&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">【响应行】</span></span>
<span class="line"><span style="color:#24292e;">HTTP/1.1 200 OK</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">【响应头】</span></span>
<span class="line"><span style="color:#24292e;">Accept-Ranges: bytes</span></span>
<span class="line"><span style="color:#24292e;">ETag: W/&quot;143-1557909081579&quot;</span></span>
<span class="line"><span style="color:#24292e;">Last-Modified: Wed, 15 May 2019 08:31:21 GMT</span></span>
<span class="line"><span style="color:#24292e;">Content-Type: text/html</span></span>
<span class="line"><span style="color:#24292e;">Content-Length: 143</span></span>
<span class="line"><span style="color:#24292e;">Date: Sun, 08 Dec 2019 02:20:04 GMT</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">【响应体】</span></span>
<span class="line"><span style="color:#24292e;">&lt;!DOCTYPE html&gt;</span></span>
<span class="line"><span style="color:#24292e;">&lt;html lang=&quot;en&quot;&gt;</span></span>
<span class="line"><span style="color:#24292e;">&lt;head&gt;</span></span>
<span class="line"><span style="color:#24292e;">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span></span>
<span class="line"><span style="color:#24292e;">    &lt;title&gt;Title&lt;/title&gt;</span></span>
<span class="line"><span style="color:#24292e;">&lt;/head&gt;</span></span>
<span class="line"><span style="color:#24292e;">&lt;body&gt;</span></span>
<span class="line"><span style="color:#24292e;">    Success</span></span>
<span class="line"><span style="color:#24292e;">&lt;/body&gt;</span></span>
<span class="line"><span style="color:#24292e;">&lt;/html&gt;</span></span></code></pre></div></li></ul><h3 id="响应行" tabindex="-1">响应行 <a class="header-anchor" href="#响应行" aria-label="Permalink to &quot;响应行&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">HTTP/1.1 200</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">HTTP/1.1 200</span></span></code></pre></div><ul><li><p>协议/版本</p></li><li><p><strong>响应状态码</strong>  (记住-背诵下来)</p><p><img src="`+U+`" alt="image-20230918121642236"></p><p>​ 200:正常,跟服务器连接成功，发送请求成功</p><p>​ 302:重定向(跳转)</p><p>​ 304:读取缓存，表示客户机缓存的版本是最新的，客户机可以继续使用它，无需到服务器请求. 读取缓存</p><p>​ 403: forbidden 权限不够，服务器接收到了客户端的请求，但是拒绝处理</p><p>​ 404:服务器接收到了客户端的请求，但是我服务器里面没有你要找的资源</p><p>​ 500:服务器接收到了客户端的请求，也找到了具体的资源处理请求，但是处理的过程中服务器出异常了</p></li></ul><h3 id="响应头" tabindex="-1">响应头 <a class="header-anchor" href="#响应头" aria-label="Permalink to &quot;响应头&quot;">​</a></h3><p>响应头以key:vaue存在, 可能多个value情况. ==服务器指示浏览器去干什么,去配置什么.==</p><ul><li><strong>Location</strong>: <a href="http://www.it315.org/index.jsp%E6%8C%87%E7%A4%BA%E6%96%B0%E7%9A%84%E8%B5%84%E6%BA%90%E7%9A%84%E4%BD%8D%E7%BD%AE" target="_blank" rel="noreferrer">http://www.it315.org/index.jsp指示新的资源的位置</a>,通常和状态,码302一起使用，完成请求重定向</li><li><strong>Content-Type</strong>: text/html; charset=UTF-8; 设置服务器发送的内容的MIME类型,文件下载时候</li></ul><p>a.mp3 b.mp4</p><ul><li><p><strong>Refresh</strong>: 5;url=<a href="http://www.baidu.com" target="_blank" rel="noreferrer">http://www.baidu.com</a> 指示客户端刷新频率。单位是秒 eg: 告诉浏览器5s之后跳转到百度</p></li><li><p><strong>Content-Disposition</strong>: attachment; filename=a.jpg 指示客户端(浏览器)下载文件</p></li><li><p>Content-Length:80 告诉浏览器正文的长度</p></li><li><p>Server:apachetomcat 服务器的类型</p></li><li><p>Content-Encoding: gzip服务器发送的数据采用的编码类型</p></li><li><p>Set-Cookie:SS=Q0=5Lb_nQ;path=/search服务器端发送的Cookie</p></li><li><p>Cache-Control: no-cache (1.1)</p></li><li><p>Pragma: no-cache  (1.0)  表示告诉客户端不要使用缓存</p></li><li><p>Connection:close/Keep-Alive</p></li><li><p>Date:Tue, 11 Jul 2000 18:23:51 GMT</p></li></ul><h3 id="响应体" tabindex="-1">响应体 <a class="header-anchor" href="#响应体" aria-label="Permalink to &quot;响应体&quot;">​</a></h3><p>​ 页面展示内容, 和网页右键查看的源码一样</p><h3 id="小结-5" tabindex="-1">小结 <a class="header-anchor" href="#小结-5" aria-label="Permalink to &quot;小结&quot;">​</a></h3><pre><code>1. 响应行：包含响应状态码
  	   	1. 常见的响应状态码:
  	          	1. 200 OK
  	          	2. 302 Redirect 重定向
  	          	3. 304 Cache 读取缓存
  	          	4. 400 BAD REQUEST 请求有问题(可能是请求参数等等不符合规定)
  	          	5. 403 Forbidden 拒绝处理
  	          	6. 404 NOT FOUND 找不到资源
  	          	7. 500 SERVER ERROR 服务器异常
2. 响应头: 由多个键值对构成
3. 响应体:
     	1. 可以用于客户端页面的展示
     	2. 可以用于下载
</code></pre><h1 id="tomcat架构设计-源码剖析" tabindex="-1">Tomcat架构设计&amp;源码剖析 <a class="header-anchor" href="#tomcat架构设计-源码剖析" aria-label="Permalink to &quot;Tomcat架构设计&amp;源码剖析&quot;">​</a></h1><ul><li><p>Tomcat功能需求分析</p></li><li><p>Tomcat套娃式架构设计（Connector层次架构、容器层次结构）</p></li><li><p>Tomcat源码构建</p></li><li><p>Tomcat源码剖析-链式初始化过程</p></li><li><p>Tomcat流程剖析-Servlet请求处理链路追踪</p></li></ul><h2 id="tomcat架构设计" tabindex="-1">Tomcat架构设计 <a class="header-anchor" href="#tomcat架构设计" aria-label="Permalink to &quot;Tomcat架构设计&quot;">​</a></h2><h3 id="tomcat的功能-需求" tabindex="-1">Tomcat的功能（需求） <a class="header-anchor" href="#tomcat的功能-需求" aria-label="Permalink to &quot;Tomcat的功能（需求）&quot;">​</a></h3><p>浏览器发给服务端的是一个 HTTP 格式的请求，HTTP 服务器收到这个请求后，需要调用服务端程序来处理，所谓的服务端程序就是你写的 Java 类，一般来说不同的请求需要由不同的 Java 类来处理。</p><p>那么问题来了，HTTP 服务器怎么知道要调用哪个 Java 类的哪个方法呢？</p><p><img src="`+F+'" alt="image-20220707094852453"></p><ul><li>HTTP 服务器直接调用具体业务类，它们是紧耦合的。</li></ul><blockquote><p>解决：HTTP 服务器不直接调用业务类，而是把请求交给容器来处理，容器通过 Servlet 接口调用业务类。因此 Servlet 接口和 Servlet 容器的出现，达到了 HTTP 服务器与业务类解耦的目的。</p></blockquote><p><img src="'+G+'" alt="image-20220707094943533"></p><p><strong>Tomcat两个非常重要的功能（身份）</strong></p><ul><li>Http服务器功能：Socket通信（TCP/IP）、解析Http报文</li><li>Servlet容器功能：有很多Servlet（自带系统级Servlet+自定义Servlet），Servlet处理具体的业务逻辑</li></ul><h3 id="tomcat的架构-设计实现" tabindex="-1">Tomcat的架构（设计实现） <a class="header-anchor" href="#tomcat的架构-设计实现" aria-label="Permalink to &quot;Tomcat的架构（设计实现）&quot;">​</a></h3><h4 id="需求" tabindex="-1">需求 <a class="header-anchor" href="#需求" aria-label="Permalink to &quot;需求&quot;">​</a></h4><p>Tomcat的需求是要实现 2 个核心功能：</p><ul><li>处理 Socket 连接，负责网络字节流与 Request 和 Response 对象的转化。=&gt; 网络通信，协议解析</li><li>加载和管理 Servlet，以及具体处理 Request 请求。=&gt; servlet容器</li></ul><h4 id="tomcat架构设计-1" tabindex="-1">Tomcat架构设计 <a class="header-anchor" href="#tomcat架构设计-1" aria-label="Permalink to &quot;Tomcat架构设计&quot;">​</a></h4><p>基于Tomcat需求，所以 Tomcat 设计了两个核心组件连接器（Connector）和容器（Container）来分别做这两件事情。 <strong>连接器</strong>负责对外交流，<strong>容器</strong>负责内部处理。</p><p><img src="'+K+'" alt="image-20220707095221858"></p><p>Tomcat中一个容器可能对接多个连接器，每一个连接器都对应某种协议某种IO模型,Tomcat将多个连接器和单个容器组成一个service组件，一个tomcat中可能存在多个Service组件Connector：将不同协议不同IO模型的请求转换为标准的标准的ServletRequest 对象交给容器处理。</p><ul><li>Container：Container本质上是一个Servlet容器,负责servelt的加载和管理，处理请求</li><li>ServletRequest，并返回标准的 ServletResponse 对象给连接器</li></ul><h4 id="连接器是如何设计的" tabindex="-1">连接器是如何设计的？ <a class="header-anchor" href="#连接器是如何设计的" aria-label="Permalink to &quot;连接器是如何设计的？&quot;">​</a></h4><h5 id="铺垫-支持协议-io模型" tabindex="-1">铺垫：支持协议&amp;IO模型 <a class="header-anchor" href="#铺垫-支持协议-io模型" aria-label="Permalink to &quot;铺垫：支持协议&amp;IO模型&quot;">​</a></h5><p>铺垫：Tomcat 是支持多种 I/O 模型和应用层协议的 Tomcat 支持的 I/O 模型有：</p><ul><li>NIO：非阻塞 I/O，采用 Java NIO 类库实现</li><li>NIO.2：异步 I/O，采用 JDK 7 最新的 NIO.2 类库实现</li><li>APR：采用 Apache 可移植运行库实现，是 C/C++ 编写的本地库</li></ul><p>Tomcat 支持的应用层协议有：</p><ul><li>HTTP/1.1：这是大部分 Web 应用采用的访问协议</li><li>AJP：用于和 Web 服务器集成（如 Apache）</li><li>HTTP/2：HTTP 2.0 大幅度的提升了 Web 性能</li></ul><h5 id="连接器架构分析" tabindex="-1">连接器架构分析 <a class="header-anchor" href="#连接器架构分析" aria-label="Permalink to &quot;连接器架构分析&quot;">​</a></h5><p>Tomcat 为了实现支持多种 I/O 模型和应用层协议，一个容器可能对接多个连接器，就好比一个房间有多个门。但是单独的连接器或者容器都不能对外提供服务，需要把它们组装起来才能工作，组装后这个整体叫作 Service 组件。这里请注意，Service 本身没有做什么重要的事情，只是在连接器和容器外面多包了一层，把它们组装在一起。Tomcat 内可能有多个 Service，这样的设计也是出于灵活性的考虑。通过在 Tomcat 中配置多个 Service，可以实现通过不同的端口号来访问同一台机器上部署的不同应用。</p><p><img src="'+Z+'" alt="image-20220707095402196"></p><p>从图上可以看到，最顶层是 Server，这里的 Server 指的就是一个 Tomcat 实例。一个 Server 中有一个或者多个 Service，一个 Service 中有多个连接器和一个容器。连接器与容器之间通过标准的ServletRequest 和 ServletResponse 通信。</p><h5 id="核心功能" tabindex="-1">核心功能 <a class="header-anchor" href="#核心功能" aria-label="Permalink to &quot;核心功能&quot;">​</a></h5><p>连接器对 Servlet 容器屏蔽了协议及 I/O 模型等的区别，无论是 HTTP 还是 AJP，在容器中获取到的都是一个标准的 ServletRequest 对象。我们可以把连接器的功能需求进一步细化，比如：</p><ul><li>监听网络端口。</li><li>接受网络连接请求。读取网络请求字节流。</li><li>根据具体应用层协议（HTTP/AJP）解析字节流，生成统一的 Tomcat Request 对象。</li><li>将 Tomcat Request 对象转成标准的 ServletRequest。</li><li>调用 Servlet 容器，得到 ServletResponse。 将 ServletResponse 转成 Tomcat Response 对象。</li><li>将 Tomcat Response 转成网络字节流。</li><li>将响应字节流写回给浏览器。</li></ul><h5 id="通用架构设计" tabindex="-1">通用架构设计 <a class="header-anchor" href="#通用架构设计" aria-label="Permalink to &quot;通用架构设计&quot;">​</a></h5><p>需求列清楚后，我们要考虑的下一个问题是，连接器应该有哪些子模块？优秀的模块化设计应该考虑高内聚、低耦合。</p><ul><li>高内聚是指相关度比较高的功能要尽可能集中，不要分散。</li><li>低耦合是指两个相关的模块要尽可能减少依赖的部分和降低依赖的程度，不要让两个模块产生强依赖。</li></ul><p>通过分析连接器的详细功能列表，我们发现连接器需要完成 3 个高内聚的功能：</p><ul><li>网络通信</li><li>应用层协议解析</li><li>Tomcat Request/Response 与 ServletRequest/ServletResponse 的转化</li></ul><p>因此 Tomcat 的设计者设计了 3 个组件来实现这 3 个功能，分别是 Endpoint、Processor 和 Adapter。</p><p><img src="'+Q+'" alt="image-20220707095531409"></p><p>由于 I/O 模型和应用层协议可以自由组合，比如 NIO + HTTP 或者 NIO.2 + AJP。Tomcat 的设计者将网络通信和应用层协议解析放在一起考虑，设计了一个叫 ProtocolHandler 的接口来封装这两种变化点</p><p><img src="'+X+'" alt="image-20220707095544595"></p><p>通过图清晰地看到它们的继承和层次关系，这样设计的目的是尽量将稳定的部分放到抽象基类，同时每一种 I/O 模型和协议的组合都有相应的具体实现类，我们在使用时可以自由选择。</p><h5 id="protocolhandler-组件" tabindex="-1">ProtocolHandler 组件 <a class="header-anchor" href="#protocolhandler-组件" aria-label="Permalink to &quot;ProtocolHandler 组件&quot;">​</a></h5><p>现在我们知道，连接器用 ProtocolHandler 来处理网络连接和应用层协议，包含了 2 个重要部件：</p><p>Endpoint 和 Processor，下面来详细介绍它们的工作原理</p><h6 id="endpoint组件" tabindex="-1">EndPoint组件 <a class="header-anchor" href="#endpoint组件" aria-label="Permalink to &quot;EndPoint组件&quot;">​</a></h6><p>Endpoint 翻译过来是&quot;通信端点&quot;,主要负责网络通信,这其中就包括,监听客户端连接创建于客户端连接Socket,并负责连接Socket 接收和发送处理器。因此Endpoint是对传输层的抽象，是用来实现 TCP/IP 协议的。</p><p><strong>EndPoint类结构图</strong></p><p>EndPoint用基类用抽象类AbstractEndpoint来表示，对于不同的Linux IO模型通过使用不同子类来实现。</p><p><img src="'+$+'" alt="image-20220707095641120"></p><p>Endpoint 是一个接口，对应的抽象实现类是 AbstractEndpoint，而 AbstractEndpoint 的具体子类，比如在 NioEndpoint 和 Nio2Endpoint 中，有两个重要的子组件：Acceptor 和 SocketProcessor。</p><p>其中 Acceptor 用于监听 Socket 连接请求。SocketProcessor 用于处理接收到的 Socket 请求，它实现Runnable 接口，在 run 方法里调用协议处理组件 Processor 进行处理。为了提高处理能力，SocketProcessor 被提交到线程池来执行。而这个线程池叫作执行器（Executor)</p><h6 id="processor组件" tabindex="-1">Processor组件 <a class="header-anchor" href="#processor组件" aria-label="Permalink to &quot;Processor组件&quot;">​</a></h6><p>Processor：翻译过来是&quot;处理器&quot;，主要负责根据具体应用层协议（HTTP/AJP）读取字节流解析成Tomcat Request 和 Response，因此Processor是对应用层的抽象，是用来实现 HTTP/AJP 协议的。</p><p><strong>Processor类结构图</strong></p><p><img src="'+Y+'" alt="image-20220707095735224"></p><p>Processor 是一个接口，定义了请求的处理等方法。它的抽象实现类 AbstractProcessor 对一些协议共有的属性进行封装，没有对方法进行实现。具体的实现有 AjpProcessor、Http11Processor 等，这些具体实现类实现了特定协议的解析方法和请求处理方式</p><h6 id="adapter组件" tabindex="-1"><strong>Adapter组件</strong> <a class="header-anchor" href="#adapter组件" aria-label="Permalink to &quot;**Adapter组件**&quot;">​</a></h6><p>由于协议不同，客户端发过来的请求信息也不尽相同，Tomcat 定义了自己的 Request 类来“存放”这些请求信息。ProtocolHandler 接口负责解析请求并生成 Tomcat Request/Response类。但是这个Request/Response 对象不是标准的 ServletRequest/ServletResponse，也就意味着，不能用TomcatRequest/Response 作为参数来调用容器。</p><p>Tomcat 设计者的解决方案是引入 CoyoteAdapter，这是适配器模式的经典运用，负责将TomcatRequest/Response 与 ServletRequest/ServletResponse 的相互转化，实现连接器（Connector）和容器（Container）的解耦。</p><h6 id="protocolhandler组件" tabindex="-1"><strong>ProtocolHandler组件</strong> <a class="header-anchor" href="#protocolhandler组件" aria-label="Permalink to &quot;**ProtocolHandler组件**&quot;">​</a></h6><p>ProtocolHandler组件EndPoint组件，Processor组件合并在一起表示协议处理器。用来处理tomcat支持多种IO模型和多种协议的组件。</p><p><strong>ProtocolHandler类图</strong></p><p><img src="'+aa+'" alt="image-20220707100309425"></p><h5 id="connector处理流程" tabindex="-1"><strong>Connector处理流程</strong> <a class="header-anchor" href="#connector处理流程" aria-label="Permalink to &quot;**Connector处理流程**&quot;">​</a></h5><p>我们再来看看连接器的组件图：</p><p><img src="'+sa+'" alt="image-20220707100327036"></p><ul><li>Endpoint内部Acceptor组件用于监听Socket 连接请求，当发送客户端连接到服务端Acceptor组件负责与客户端建立连接创建Socket,每当连接客户端发起请求，Endpoint会创建一个SocketProcessor对象SocketProcessor 用于处理接收到的 Socket 请求，它实现 Runnable 接口，在 run 方法里调用协议处理组件 Processor 进行处理。为了提高处理能力，SocketProcessor 被提交到线程池来执行。而这个线程池叫作执行器（Executor)</li><li>Processor 接收来自 Endpoint 的 Socket，读取字节流解析成 Tomcat Request 和 Response 对象，接着会调用 Adapter 的 Service 方法。并通过 Adapter 将其提交到容器处理</li><li>连接器调用 CoyoteAdapter 的 sevice 方法，传入的是 Tomcat Request 对象，CoyoteAdapter 负责将 Tomcat Request 转成 ServletRequest，再调用容器的 service 方法。</li></ul><h5 id="容器的本质" tabindex="-1"><strong>容器的本质</strong> <a class="header-anchor" href="#容器的本质" aria-label="Permalink to &quot;**容器的本质**&quot;">​</a></h5><p>Tomcat 有两个核心组件：连接器和容器</p><p><img src="'+ea+'" alt="image-20220707100638150"></p><p>容器，顾名思义就是用来装载东西的器具，在 Tomcat 里，容器就是用来装载 Servlet 的。那 Tomcat的 Servlet 容器是如何设计的呢？</p><p>Container本质上是一个Servlet容器,负责servelt的加载和管理，处理请求ServletRequest，并返回标准的 ServletResponse 对象给连接器</p><h5 id="容器工作流程" tabindex="-1"><strong>容器工作流程</strong> <a class="header-anchor" href="#容器工作流程" aria-label="Permalink to &quot;**容器工作流程**&quot;">​</a></h5><p>当客户请求某个资源时，HTTP 服务器会用一个 ServletRequest 对象把客户的请求信息封装起来，然后调用 Servlet 容器的 service 方法，Servlet 容器拿到请求后，根据请求的 URL 和 Servlet 的映射关系，找到相应的 Servlet，如果 Servlet 还没有被加载，就用反射机制创建这个 Servlet，并调用 Servlet 的init 方法来完成初始化，接着调用 Servlet 的 service 方法来处理请求，把 ServletResponse 对象返回给HTTP 服务器，HTTP 服务器会把响应发送给客户端</p><p><img src="'+na+'" alt="image-20220707100739382"></p><h5 id="容器层次结构" tabindex="-1"><strong>容器层次结构</strong> <a class="header-anchor" href="#容器层次结构" aria-label="Permalink to &quot;**容器层次结构**&quot;">​</a></h5><p>Tomcat 设计了 4 种容器组件，分别是 Engine、Host、Context 和 Wrapper。这 4 种容器不是平行关系，而是父子关系。</p><p>如图：</p><p><img src="'+la+'" alt="image-20220707100908090"></p><ul><li>Wrapper:表示一个 Servlet</li><li>Context:表示一个 Web 应用程序，一个 Web 应用程序中可能会有多个 Servlet</li><li>Host:表示的是一个虚拟主机，或者说一个站点，可以给 Tomcat 配置多个虚拟主机地址，而一个虚拟主机下可以部署多个 Web 应用程序</li><li>Engine:表示引擎，用来管理多个虚拟站点，一个 Service 最多只能有一个 Engine。</li></ul><p>可以再通过 Tomcat 的server.xml配置文件来加深对 Tomcat 容器的理解。Tomcat 采用了组件化的设计，它的构成组件都是可配置的，其中最外层的是 Server，其他组件按照一定的格式要求配置在这个顶层容器中。</p><p><img src="'+pa+`" alt="image-20220707100937809"></p><h5 id="组件类图" tabindex="-1"><strong>组件类图</strong> <a class="header-anchor" href="#组件类图" aria-label="Permalink to &quot;**组件类图**&quot;">​</a></h5><p>问题：Tomcat 是怎么管理这些容器组件？</p><p>Container容器中定义了Container 接口用来描述Container容器中所有的组件，不同的子组件分别定义了不同子接口做描述。容器组件之间具有父子关系。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">public interface Container extends Lifecycle { </span></span>
<span class="line"><span style="color:#e1e4e8;">    public void setName(String name); </span></span>
<span class="line"><span style="color:#e1e4e8;">    public Container getParent(); </span></span>
<span class="line"><span style="color:#e1e4e8;">    public void setParent(Container container); </span></span>
<span class="line"><span style="color:#e1e4e8;">    public void addChild(Container child); </span></span>
<span class="line"><span style="color:#e1e4e8;">    public void removeChild(Container child); </span></span>
<span class="line"><span style="color:#e1e4e8;">    public Container findChild(String name); </span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">public interface Container extends Lifecycle { </span></span>
<span class="line"><span style="color:#24292e;">    public void setName(String name); </span></span>
<span class="line"><span style="color:#24292e;">    public Container getParent(); </span></span>
<span class="line"><span style="color:#24292e;">    public void setParent(Container container); </span></span>
<span class="line"><span style="color:#24292e;">    public void addChild(Container child); </span></span>
<span class="line"><span style="color:#24292e;">    public void removeChild(Container child); </span></span>
<span class="line"><span style="color:#24292e;">    public Container findChild(String name); </span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><p><img src="`+ta+'" alt="image-20220707101535636"></p><p>从接口看到了 getParent、setParent、addChild 和 removeChild 等方法。可能还注意到 Container 接口扩展了 Lifecycle 接口，Lifecycle 接口用来统一管理各组件的生命周期</p><h5 id="套娃式架构设计的好处" tabindex="-1"><strong>套娃式架构设计的好处</strong> <a class="header-anchor" href="#套娃式架构设计的好处" aria-label="Permalink to &quot;**套娃式架构设计的好处**&quot;">​</a></h5><p><img src="'+oa+'" alt="image-20220707101553907"></p><ul><li>一层套一层的方式，其实组件关系还是很清晰的，也便于后期组件生命周期管理</li><li>tomcat这种架构设计正好和xml配置文件中标签的包含方式对应上，那么后续在解读xml以及封装对象的过程中就容易对应</li><li>便于子容器继承父容器的一些配置</li></ul><h2 id="tomcat源码环境构建" tabindex="-1">Tomcat源码环境构建 <a class="header-anchor" href="#tomcat源码环境构建" aria-label="Permalink to &quot;Tomcat源码环境构建&quot;">​</a></h2><h3 id="apache-tomcat源码下载" tabindex="-1"><strong>Apache Tomcat源码下载</strong> <a class="header-anchor" href="#apache-tomcat源码下载" aria-label="Permalink to &quot;**Apache Tomcat源码下载**&quot;">​</a></h3><p>下载地址：<a href="https://tomcat.apache.org/download-80.cg" target="_blank" rel="noreferrer">https://tomcat.apache.org/download-80.cg</a></p><p><img src="'+ia+'" alt="image-20220707101650332"></p><h3 id="解压apache-tomcat-8-5-73-src-zip" tabindex="-1">解压<code>apache-tomcat-8.5.73-src.zip</code> <a class="header-anchor" href="#解压apache-tomcat-8-5-73-src-zip" aria-label="Permalink to &quot;解压`apache-tomcat-8.5.73-src.zip`&quot;">​</a></h3><p><img src="'+ca+`" alt="image-20220707101710136"></p><h3 id="apache-tomcat-8-5-73-src目录下添加pom文件" tabindex="-1"><code>apache-tomcat-8.5.73-src</code>目录下添加pom文件 <a class="header-anchor" href="#apache-tomcat-8-5-73-src目录下添加pom文件" aria-label="Permalink to &quot;\`apache-tomcat-8.5.73-src\`目录下添加pom文件&quot;">​</a></h3><p>因为下载下来的源码包没有pom文件，为了编译并以maven项目运行，需要手动构建一下pom文件</p><p>pom文件如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span>
<span class="line"><span style="color:#e1e4e8;">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span>
<span class="line"><span style="color:#e1e4e8;">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0</span></span>
<span class="line"><span style="color:#e1e4e8;">            http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">    &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">    &lt;artifactId&gt;apache-tomcat-8.5.73-src&lt;/artifactId&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">    &lt;name&gt;Tomcat8.5&lt;/name&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">    &lt;version&gt;8.5&lt;/version&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">    &lt;build&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">        &lt;!--指定源目录--&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">        &lt;finalName&gt;Tomcat8.5&lt;/finalName&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">        &lt;sourceDirectory&gt;java&lt;/sourceDirectory&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">        &lt;resources&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">        &lt;resource&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">                &lt;directory&gt;java&lt;/directory&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">            &lt;/resource&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">        &lt;/resources&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">        &lt;plugins&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">            &lt;!--引入编译插件--&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">            &lt;plugin&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">                &lt;version&gt;3.1&lt;/version&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">                &lt;configuration&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">                    &lt;source&gt;1.8&lt;/source&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">                    &lt;target&gt;1.8&lt;/target&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">                &lt;/configuration&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">            &lt;/plugin&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">        &lt;/plugins&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">    &lt;/build&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">    &lt;!--tomcat 依赖的基础包--&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">    &lt;dependencies&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">        &lt;dependency&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">            &lt;groupId&gt;org.easymock&lt;/groupId&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">            &lt;artifactId&gt;easymock&lt;/artifactId&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">            &lt;version&gt;3.4&lt;/version&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">        &lt;/dependency&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">        &lt;dependency&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">            &lt;groupId&gt;ant&lt;/groupId&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">            &lt;artifactId&gt;ant&lt;/artifactId&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">            &lt;version&gt;1.7.0&lt;/version&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">        &lt;/dependency&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">        &lt;dependency&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">            &lt;groupId&gt;wsdl4j&lt;/groupId&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">            &lt;artifactId&gt;wsdl4j&lt;/artifactId&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">            &lt;version&gt;1.6.2&lt;/version&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">        &lt;/dependency&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">        &lt;dependency&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">            &lt;groupId&gt;javax.xml&lt;/groupId&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">            &lt;artifactId&gt;jaxrpc&lt;/artifactId&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">            &lt;version&gt;1.1&lt;/version&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">        &lt;/dependency&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">        &lt;dependency&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">            &lt;groupId&gt;org.eclipse.jdt.core.compiler&lt;/groupId&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">            &lt;artifactId&gt;ecj&lt;/artifactId&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">            &lt;version&gt;4.5.1&lt;/version&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">        &lt;/dependency&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">    &lt;/dependencies&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">&lt;/project&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span>
<span class="line"><span style="color:#24292e;">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span>
<span class="line"><span style="color:#24292e;">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span>
<span class="line"><span style="color:#24292e;">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0</span></span>
<span class="line"><span style="color:#24292e;">            http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span></span>
<span class="line"><span style="color:#24292e;">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span></span>
<span class="line"><span style="color:#24292e;">    &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;</span></span>
<span class="line"><span style="color:#24292e;">    &lt;artifactId&gt;apache-tomcat-8.5.73-src&lt;/artifactId&gt;</span></span>
<span class="line"><span style="color:#24292e;">    &lt;name&gt;Tomcat8.5&lt;/name&gt;</span></span>
<span class="line"><span style="color:#24292e;">    &lt;version&gt;8.5&lt;/version&gt;</span></span>
<span class="line"><span style="color:#24292e;">    &lt;build&gt;</span></span>
<span class="line"><span style="color:#24292e;">        &lt;!--指定源目录--&gt;</span></span>
<span class="line"><span style="color:#24292e;">        &lt;finalName&gt;Tomcat8.5&lt;/finalName&gt;</span></span>
<span class="line"><span style="color:#24292e;">        &lt;sourceDirectory&gt;java&lt;/sourceDirectory&gt;</span></span>
<span class="line"><span style="color:#24292e;">        &lt;resources&gt;</span></span>
<span class="line"><span style="color:#24292e;">        &lt;resource&gt;</span></span>
<span class="line"><span style="color:#24292e;">                &lt;directory&gt;java&lt;/directory&gt;</span></span>
<span class="line"><span style="color:#24292e;">            &lt;/resource&gt;</span></span>
<span class="line"><span style="color:#24292e;">        &lt;/resources&gt;</span></span>
<span class="line"><span style="color:#24292e;">        &lt;plugins&gt;</span></span>
<span class="line"><span style="color:#24292e;">            &lt;!--引入编译插件--&gt;</span></span>
<span class="line"><span style="color:#24292e;">            &lt;plugin&gt;</span></span>
<span class="line"><span style="color:#24292e;">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span></span>
<span class="line"><span style="color:#24292e;">                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span></span>
<span class="line"><span style="color:#24292e;">                &lt;version&gt;3.1&lt;/version&gt;</span></span>
<span class="line"><span style="color:#24292e;">                &lt;configuration&gt;</span></span>
<span class="line"><span style="color:#24292e;">                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;</span></span>
<span class="line"><span style="color:#24292e;">                    &lt;source&gt;1.8&lt;/source&gt;</span></span>
<span class="line"><span style="color:#24292e;">                    &lt;target&gt;1.8&lt;/target&gt;</span></span>
<span class="line"><span style="color:#24292e;">                &lt;/configuration&gt;</span></span>
<span class="line"><span style="color:#24292e;">            &lt;/plugin&gt;</span></span>
<span class="line"><span style="color:#24292e;">        &lt;/plugins&gt;</span></span>
<span class="line"><span style="color:#24292e;">    &lt;/build&gt;</span></span>
<span class="line"><span style="color:#24292e;">    &lt;!--tomcat 依赖的基础包--&gt;</span></span>
<span class="line"><span style="color:#24292e;">    &lt;dependencies&gt;</span></span>
<span class="line"><span style="color:#24292e;">        &lt;dependency&gt;</span></span>
<span class="line"><span style="color:#24292e;">            &lt;groupId&gt;org.easymock&lt;/groupId&gt;</span></span>
<span class="line"><span style="color:#24292e;">            &lt;artifactId&gt;easymock&lt;/artifactId&gt;</span></span>
<span class="line"><span style="color:#24292e;">            &lt;version&gt;3.4&lt;/version&gt;</span></span>
<span class="line"><span style="color:#24292e;">        &lt;/dependency&gt;</span></span>
<span class="line"><span style="color:#24292e;">        &lt;dependency&gt;</span></span>
<span class="line"><span style="color:#24292e;">            &lt;groupId&gt;ant&lt;/groupId&gt;</span></span>
<span class="line"><span style="color:#24292e;">            &lt;artifactId&gt;ant&lt;/artifactId&gt;</span></span>
<span class="line"><span style="color:#24292e;">            &lt;version&gt;1.7.0&lt;/version&gt;</span></span>
<span class="line"><span style="color:#24292e;">        &lt;/dependency&gt;</span></span>
<span class="line"><span style="color:#24292e;">        &lt;dependency&gt;</span></span>
<span class="line"><span style="color:#24292e;">            &lt;groupId&gt;wsdl4j&lt;/groupId&gt;</span></span>
<span class="line"><span style="color:#24292e;">            &lt;artifactId&gt;wsdl4j&lt;/artifactId&gt;</span></span>
<span class="line"><span style="color:#24292e;">            &lt;version&gt;1.6.2&lt;/version&gt;</span></span>
<span class="line"><span style="color:#24292e;">        &lt;/dependency&gt;</span></span>
<span class="line"><span style="color:#24292e;">        &lt;dependency&gt;</span></span>
<span class="line"><span style="color:#24292e;">            &lt;groupId&gt;javax.xml&lt;/groupId&gt;</span></span>
<span class="line"><span style="color:#24292e;">            &lt;artifactId&gt;jaxrpc&lt;/artifactId&gt;</span></span>
<span class="line"><span style="color:#24292e;">            &lt;version&gt;1.1&lt;/version&gt;</span></span>
<span class="line"><span style="color:#24292e;">        &lt;/dependency&gt;</span></span>
<span class="line"><span style="color:#24292e;">        &lt;dependency&gt;</span></span>
<span class="line"><span style="color:#24292e;">            &lt;groupId&gt;org.eclipse.jdt.core.compiler&lt;/groupId&gt;</span></span>
<span class="line"><span style="color:#24292e;">            &lt;artifactId&gt;ecj&lt;/artifactId&gt;</span></span>
<span class="line"><span style="color:#24292e;">            &lt;version&gt;4.5.1&lt;/version&gt;</span></span>
<span class="line"><span style="color:#24292e;">        &lt;/dependency&gt;</span></span>
<span class="line"><span style="color:#24292e;">    &lt;/dependencies&gt;</span></span>
<span class="line"><span style="color:#24292e;">&lt;/project&gt;</span></span></code></pre></div><h3 id="创建catalina-home目录" tabindex="-1">创建catalina-home目录 <a class="header-anchor" href="#创建catalina-home目录" aria-label="Permalink to &quot;创建catalina-home目录&quot;">​</a></h3><p><img src="`+ra+'" alt="image-20220707101832239"></p><p><img src="'+ga+'" alt="image-20220707101838069"></p><p>将bin、conf、webapps目录复制到catalina-home目录中：</p><p><img src="'+da+'" alt="image-20220707101845965"></p><p>其余文件夹手动进行创建：</p><p><img src="'+ma+'" alt="image-20220707101856580"></p><h3 id="导入idea" tabindex="-1">导入IDEA <a class="header-anchor" href="#导入idea" aria-label="Permalink to &quot;导入IDEA&quot;">​</a></h3><p><img src="'+ha+`" alt="image-20220707101914213"></p><p>新建application 设置main类和vm参数</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">Main class: org.apache.catalina.startup.Bootstrap </span></span>
<span class="line"><span style="color:#e1e4e8;">VM options: 配置自己的catalina-home目录</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">Main class: org.apache.catalina.startup.Bootstrap </span></span>
<span class="line"><span style="color:#24292e;">VM options: 配置自己的catalina-home目录</span></span></code></pre></div><p><img src="`+ua+`" alt="image-20220707101931503"></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">-Dcatalina.home=catalina-home</span></span>
<span class="line"><span style="color:#e1e4e8;">-Dcatalina.base=catalina-home</span></span>
<span class="line"><span style="color:#e1e4e8;">-Djava.io.tmpdir=catalina-home/temp</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">-Dcatalina.home=catalina-home</span></span>
<span class="line"><span style="color:#24292e;">-Dcatalina.base=catalina-home</span></span>
<span class="line"><span style="color:#24292e;">-Djava.io.tmpdir=catalina-home/temp</span></span></code></pre></div><p>打开ContextConfig 添加一行代码</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">//初始化JSP解析引擎 </span></span>
<span class="line"><span style="color:#e1e4e8;">context.addServletContainerInitializer(new JasperInitializer(),null);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">//初始化JSP解析引擎 </span></span>
<span class="line"><span style="color:#24292e;">context.addServletContainerInitializer(new JasperInitializer(),null);</span></span></code></pre></div><p><img src="`+ya+'" alt="image-20220707101959617"></p><h3 id="启动执行【常见错误解决】" tabindex="-1"><strong>启动执行【常见错误解决】</strong> <a class="header-anchor" href="#启动执行【常见错误解决】" aria-label="Permalink to &quot;**启动执行【常见错误解决】**&quot;">​</a></h3><p><img src="'+ba+'" alt="image-20220707102011869"></p><p>报错</p><p><img src="'+va+'" alt="image-20220707102025207"></p><p>解决：</p><p>将JmxRemoteLifecycleListener类 全部注释，再次启动</p><p><img src="'+qa+'" alt="image-20220707102029146"></p><p>启动成功：</p><p><img src="'+Ta+'" alt="image-20220707102036811"></p><h2 id="如何实现一键式启停" tabindex="-1">如何实现一键式启停 <a class="header-anchor" href="#如何实现一键式启停" aria-label="Permalink to &quot;如何实现一键式启停&quot;">​</a></h2><p>Tomcat里面有各种各样的组件，每个组件各司其职，组件之间又相互协作共同完成web服务器这样的工程。</p><p>组件的层次关系：</p><p><img src="'+fa+`" alt="image-20220707102047832"></p><p>上面这张图描述了组件之间的静态关系，如果想让一个系统能够对外提供服务，我们需要创建、组装并启动这些组件；在服务停止的时候，我们还需要释放资源，销毁这些组件，因此这是一个动态的过程。</p><p>也就是说，Tomcat 需要动态地管理这些组件的生命周期。</p><p>组件关系：</p><p>先来看看组件之间的关系。如果你仔细分析过这些组件，可以发现它们具有两层关系。</p><ul><li>第一层关系是组件有大有小，大组件管理小组件，比如 Server 管理 Service，Service 又管理连接器和容器。</li><li>第二层关系是组件有外有内，外层组件控制内层组件，比如连接器是外层组件，负责对外交流，外层组件调用内层组件完成业务功能。也就是说，请求的处理过程是由外层组件来驱动的。</li></ul><p>这两层关系决定了系统在创建组件时应该遵循一定的顺序。</p><ul><li>第一个原则是先创建子组件，再创建父组件，子组件需要被“注入”到父组件中。</li><li>第二个原则是先创建内层组件，再创建外层组件，内层组件需要被“注入”到外层组件</li></ul><p>因此，最直观的做法就是将图上所有的组件按照先小后大、先内后外的顺序创建出来，然后组装在一起。不知道注意到没有，这个思路其实很有问题！因为这样不仅会造成代码逻辑混乱和组件遗漏，而且也不利于后期的功能扩展。为了解决这个问题，我们希望找到一种通用的、统一的方法来管理组件的生命周期，就像汽车“一键启动”那样的效果。</p><p>思考：如何统一管理组件的创建、初始化、启动、停止和销毁？</p><h4 id="一键式启停-lifecycle-接口" tabindex="-1"><strong>一键式启停：Lifecycle 接口</strong> <a class="header-anchor" href="#一键式启停-lifecycle-接口" aria-label="Permalink to &quot;**一键式启停：Lifecycle 接口**&quot;">​</a></h4><p>Lifecycle 接口里应该定义这么几个方法：init、start、stop 和 destroy，每个具体的组件去实现这些方法。</p><p>Lifecycle 接口</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">public interface Lifecycle {</span></span>
<span class="line"><span style="color:#e1e4e8;">    ....</span></span>
<span class="line"><span style="color:#e1e4e8;">    // 初始化方法</span></span>
<span class="line"><span style="color:#e1e4e8;">    public void init() throws LifecycleException;</span></span>
<span class="line"><span style="color:#e1e4e8;">    // 启动方法</span></span>
<span class="line"><span style="color:#e1e4e8;">    public void start() throws LifecycleException;</span></span>
<span class="line"><span style="color:#e1e4e8;">    // 停止方法，和start对应</span></span>
<span class="line"><span style="color:#e1e4e8;">    public void stop() throws LifecycleException;</span></span>
<span class="line"><span style="color:#e1e4e8;">    // 销毁方法，和init对应</span></span>
<span class="line"><span style="color:#e1e4e8;">    public void destroy() throws LifecycleException;</span></span>
<span class="line"><span style="color:#e1e4e8;">    // 获取生命周期状态</span></span>
<span class="line"><span style="color:#e1e4e8;">    public LifecycleState getState();</span></span>
<span class="line"><span style="color:#e1e4e8;">    // 获取字符串类型的生命周期状态</span></span>
<span class="line"><span style="color:#e1e4e8;">    public String getStateName();</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">public interface Lifecycle {</span></span>
<span class="line"><span style="color:#24292e;">    ....</span></span>
<span class="line"><span style="color:#24292e;">    // 初始化方法</span></span>
<span class="line"><span style="color:#24292e;">    public void init() throws LifecycleException;</span></span>
<span class="line"><span style="color:#24292e;">    // 启动方法</span></span>
<span class="line"><span style="color:#24292e;">    public void start() throws LifecycleException;</span></span>
<span class="line"><span style="color:#24292e;">    // 停止方法，和start对应</span></span>
<span class="line"><span style="color:#24292e;">    public void stop() throws LifecycleException;</span></span>
<span class="line"><span style="color:#24292e;">    // 销毁方法，和init对应</span></span>
<span class="line"><span style="color:#24292e;">    public void destroy() throws LifecycleException;</span></span>
<span class="line"><span style="color:#24292e;">    // 获取生命周期状态</span></span>
<span class="line"><span style="color:#24292e;">    public LifecycleState getState();</span></span>
<span class="line"><span style="color:#24292e;">    // 获取字符串类型的生命周期状态</span></span>
<span class="line"><span style="color:#24292e;">    public String getStateName();</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><p>在这样的设计中，在父组件的 init 方法里需要创建子组件并调用子组件的 init 方法。同样，在父组件的 start 方法里也需要调用子组件的 start 方法，因此调用者可以无差别的调用各组件的 init 方法和 start 方法，这就是组合模式的使用，并且只要调用最顶层组件，也就是 Server 组件的 init 和 start 方法，整个 Tomcat 就被启动起来了</p><h5 id="重用性-lifecyclebase-抽象基类" tabindex="-1">重用性：LifecycleBase 抽象基类 <a class="header-anchor" href="#重用性-lifecyclebase-抽象基类" aria-label="Permalink to &quot;重用性：LifecycleBase 抽象基类&quot;">​</a></h5><p>有了接口，我们就要用类去实现接口。一般来说实现类不止一个，不同的类在实现接口时往往会有一些 相同的逻辑，如果让各个子类都去实现一遍，就会有重复代码。那子类如何重用这部分逻辑呢？其实就是定义一个基类来实现共同的逻辑，然后让各个子类去继承它，就达到了重用的目的。而基类中往往会定义一些抽象方法，所谓的抽象方法就是说基类不会去实现这些方法，而是调用这些方法来实现骨架逻辑。抽象方法是留给各个子类去实现的，并且子类必须实现，否则无法实例化。</p><p><img src="`+ka+`" alt="image-20220707102230680"></p><p>Tomcat 定义一个基类 LifecycleBase 来实现 Lifecycle 接口，把一些公共的逻辑放到基类中去，比如生命状态的转变与维护、生命事件的触发以及监听器的添加和删除等，而子类就负责实现自己的初始化、启动和停止等方法</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">@Override</span></span>
<span class="line"><span style="color:#e1e4e8;">public final synchronized void init() throws LifecycleException {</span></span>
<span class="line"><span style="color:#e1e4e8;">    //1. 状态检查</span></span>
<span class="line"><span style="color:#e1e4e8;">    if (!state.equals(LifecycleState.NEW)) {</span></span>
<span class="line"><span style="color:#e1e4e8;">        invalidTransition(Lifecycle.BEFORE_INIT_EVENT);</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">    try {</span></span>
<span class="line"><span style="color:#e1e4e8;">        //2.触发INITIALIZING事件的监听器</span></span>
<span class="line"><span style="color:#e1e4e8;">        setStateInternal(LifecycleState.INITIALIZING, null, false);</span></span>
<span class="line"><span style="color:#e1e4e8;">        </span></span>
<span class="line"><span style="color:#e1e4e8;">        //3.调用具体子类的初始化方法</span></span>
<span class="line"><span style="color:#e1e4e8;">        initInternal();</span></span>
<span class="line"><span style="color:#e1e4e8;">        </span></span>
<span class="line"><span style="color:#e1e4e8;">        //4. 触发INITIALIZED事件的监听器</span></span>
<span class="line"><span style="color:#e1e4e8;">        setStateInternal(LifecycleState.INITIALIZED, null, false);</span></span>
<span class="line"><span style="color:#e1e4e8;">    } catch (Throwable t) {</span></span>
<span class="line"><span style="color:#e1e4e8;">      ...</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">@Override</span></span>
<span class="line"><span style="color:#24292e;">public final synchronized void init() throws LifecycleException {</span></span>
<span class="line"><span style="color:#24292e;">    //1. 状态检查</span></span>
<span class="line"><span style="color:#24292e;">    if (!state.equals(LifecycleState.NEW)) {</span></span>
<span class="line"><span style="color:#24292e;">        invalidTransition(Lifecycle.BEFORE_INIT_EVENT);</span></span>
<span class="line"><span style="color:#24292e;">    }</span></span>
<span class="line"><span style="color:#24292e;">    try {</span></span>
<span class="line"><span style="color:#24292e;">        //2.触发INITIALIZING事件的监听器</span></span>
<span class="line"><span style="color:#24292e;">        setStateInternal(LifecycleState.INITIALIZING, null, false);</span></span>
<span class="line"><span style="color:#24292e;">        </span></span>
<span class="line"><span style="color:#24292e;">        //3.调用具体子类的初始化方法</span></span>
<span class="line"><span style="color:#24292e;">        initInternal();</span></span>
<span class="line"><span style="color:#24292e;">        </span></span>
<span class="line"><span style="color:#24292e;">        //4. 触发INITIALIZED事件的监听器</span></span>
<span class="line"><span style="color:#24292e;">        setStateInternal(LifecycleState.INITIALIZED, null, false);</span></span>
<span class="line"><span style="color:#24292e;">    } catch (Throwable t) {</span></span>
<span class="line"><span style="color:#24292e;">      ...</span></span>
<span class="line"><span style="color:#24292e;">    }</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><h2 id="源码剖析-tomcat启动流程" tabindex="-1">源码剖析-Tomcat启动流程 <a class="header-anchor" href="#源码剖析-tomcat启动流程" aria-label="Permalink to &quot;源码剖析-Tomcat启动流程&quot;">​</a></h2><h3 id="启动总流程图" tabindex="-1">启动总流程图 <a class="header-anchor" href="#启动总流程图" aria-label="Permalink to &quot;启动总流程图&quot;">​</a></h3><p>使用Tomcat时，通过 Tomcat 的/bin目录下的脚本startup.sh来启动 Tomcat，那执行了这个脚本后发生了什么呢？</p><p>流程图：</p><p><img src="`+Pa+`" alt="image-20220707102351453"></p><ul><li>1.Tomcat 本质上是一个 Java 程序，因此startup.sh脚本会启动一个 JVM 来运行 Tomcat 的启动类 Bootstrap</li><li>2.Bootstrap 的主要任务是初始化 Tomcat 的类加载器，并且创建 Catalina</li><li>3.Catalina 是一个启动类，它通过解析server.xml、创建相应的组件，并调用 Server 的 start 方法</li><li>4.Server 组件的职责就是管理 Service 组件，它会负责调用 Service 的 start 方法</li><li>5.Service 组件的职责就是管理连接器和顶层容器 Engine，因此它会调用连接器和 Engine 的 start 方法。</li></ul><p>这样 Tomcat 的启动就算完成了</p><h4 id="_1-启动流程细节" tabindex="-1">(1）启动流程细节 <a class="header-anchor" href="#_1-启动流程细节" aria-label="Permalink to &quot;(1）启动流程细节&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">startup.sh --&gt; catalina.sh start --&gt; java xxxx.jar org.apache.catalina.startup.Bootstrap(main) </span></span>
<span class="line"><span style="color:#e1e4e8;">start(参数)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">startup.sh --&gt; catalina.sh start --&gt; java xxxx.jar org.apache.catalina.startup.Bootstrap(main) </span></span>
<span class="line"><span style="color:#24292e;">start(参数)</span></span></code></pre></div><p><img src="`+Ca+`" alt="image-20220707102444775"></p><p>tips：</p><ul><li>Bootstrap.init</li><li>Catalina.load</li><li>Catalina.start</li></ul><h3 id="bootstrap-init" tabindex="-1"><strong><code>Bootstrap#init();</code></strong> <a class="header-anchor" href="#bootstrap-init" aria-label="Permalink to &quot;**\`Bootstrap#init();\`**&quot;">​</a></h3><p>1、初始化类加载器</p><p>2、加载catalina类，并且实例化</p><p>3、反射调用Catalina的setParentClassLoader方法</p><p>4、实例 赋值</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">//1、初始化类加载器</span></span>
<span class="line"><span style="color:#e1e4e8;">    //2、加载catalina类，并且实例化</span></span>
<span class="line"><span style="color:#e1e4e8;">    //3、反射调用Catalina的setParentClassLoader方法</span></span>
<span class="line"><span style="color:#e1e4e8;">    //4、实例 赋值</span></span>
<span class="line"><span style="color:#e1e4e8;">    public void init() throws Exception {</span></span>
<span class="line"><span style="color:#e1e4e8;">        // 1. 初始化Tomcat类加载器(3个类加载器)</span></span>
<span class="line"><span style="color:#e1e4e8;">        initClassLoaders();</span></span>
<span class="line"><span style="color:#e1e4e8;">        Thread.currentThread().setContextClassLoader(catalinaLoader);</span></span>
<span class="line"><span style="color:#e1e4e8;">        SecurityClassLoad.securityClassLoad(catalinaLoader);</span></span>
<span class="line"><span style="color:#e1e4e8;">        // Load our startup class and call its process() method</span></span>
<span class="line"><span style="color:#e1e4e8;">        if (log.isDebugEnabled())</span></span>
<span class="line"><span style="color:#e1e4e8;">            log.debug(&quot;Loading startup class&quot;);</span></span>
<span class="line"><span style="color:#e1e4e8;">        // 2. 实例化Catalina实例</span></span>
<span class="line"><span style="color:#e1e4e8;">        Class&lt;?&gt; startupClass = </span></span>
<span class="line"><span style="color:#e1e4e8;">catalinaLoader.loadClass(&quot;org.apache.catalina.startup.Catalina&quot;);</span></span>
<span class="line"><span style="color:#e1e4e8;">        Object startupInstance = startupClass.getConstructor().newInstance();</span></span>
<span class="line"><span style="color:#e1e4e8;">        // Set the shared extensions class loader</span></span>
<span class="line"><span style="color:#e1e4e8;">        if (log.isDebugEnabled())</span></span>
<span class="line"><span style="color:#e1e4e8;">            log.debug(&quot;Setting startup class properties&quot;);</span></span>
<span class="line"><span style="color:#e1e4e8;">        String methodName = &quot;setParentClassLoader&quot;;</span></span>
<span class="line"><span style="color:#e1e4e8;">        Class&lt;?&gt; paramTypes[] = new Class[1];</span></span>
<span class="line"><span style="color:#e1e4e8;">        paramTypes[0] = Class.forName(&quot;java.lang.ClassLoader&quot;);</span></span>
<span class="line"><span style="color:#e1e4e8;">        Object paramValues[] = new Object[1];</span></span>
<span class="line"><span style="color:#e1e4e8;">        paramValues[0] = sharedLoader;</span></span>
<span class="line"><span style="color:#e1e4e8;">        // 3. 反射调用Catalina的setParentClassLoader方法，将sharedLoader设置为</span></span>
<span class="line"><span style="color:#e1e4e8;">Catalina的parentClassLoader成员变量</span></span>
<span class="line"><span style="color:#e1e4e8;">        Method method =</span></span>
<span class="line"><span style="color:#e1e4e8;">                startupInstance.getClass().getMethod(methodName, paramTypes);</span></span>
<span class="line"><span style="color:#e1e4e8;">        method.invoke(startupInstance, paramValues);</span></span>
<span class="line"><span style="color:#e1e4e8;">        //4、将catalina实例赋值</span></span>
<span class="line"><span style="color:#e1e4e8;">        catalinaDaemon = startupInstance;</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">//1、初始化类加载器</span></span>
<span class="line"><span style="color:#24292e;">    //2、加载catalina类，并且实例化</span></span>
<span class="line"><span style="color:#24292e;">    //3、反射调用Catalina的setParentClassLoader方法</span></span>
<span class="line"><span style="color:#24292e;">    //4、实例 赋值</span></span>
<span class="line"><span style="color:#24292e;">    public void init() throws Exception {</span></span>
<span class="line"><span style="color:#24292e;">        // 1. 初始化Tomcat类加载器(3个类加载器)</span></span>
<span class="line"><span style="color:#24292e;">        initClassLoaders();</span></span>
<span class="line"><span style="color:#24292e;">        Thread.currentThread().setContextClassLoader(catalinaLoader);</span></span>
<span class="line"><span style="color:#24292e;">        SecurityClassLoad.securityClassLoad(catalinaLoader);</span></span>
<span class="line"><span style="color:#24292e;">        // Load our startup class and call its process() method</span></span>
<span class="line"><span style="color:#24292e;">        if (log.isDebugEnabled())</span></span>
<span class="line"><span style="color:#24292e;">            log.debug(&quot;Loading startup class&quot;);</span></span>
<span class="line"><span style="color:#24292e;">        // 2. 实例化Catalina实例</span></span>
<span class="line"><span style="color:#24292e;">        Class&lt;?&gt; startupClass = </span></span>
<span class="line"><span style="color:#24292e;">catalinaLoader.loadClass(&quot;org.apache.catalina.startup.Catalina&quot;);</span></span>
<span class="line"><span style="color:#24292e;">        Object startupInstance = startupClass.getConstructor().newInstance();</span></span>
<span class="line"><span style="color:#24292e;">        // Set the shared extensions class loader</span></span>
<span class="line"><span style="color:#24292e;">        if (log.isDebugEnabled())</span></span>
<span class="line"><span style="color:#24292e;">            log.debug(&quot;Setting startup class properties&quot;);</span></span>
<span class="line"><span style="color:#24292e;">        String methodName = &quot;setParentClassLoader&quot;;</span></span>
<span class="line"><span style="color:#24292e;">        Class&lt;?&gt; paramTypes[] = new Class[1];</span></span>
<span class="line"><span style="color:#24292e;">        paramTypes[0] = Class.forName(&quot;java.lang.ClassLoader&quot;);</span></span>
<span class="line"><span style="color:#24292e;">        Object paramValues[] = new Object[1];</span></span>
<span class="line"><span style="color:#24292e;">        paramValues[0] = sharedLoader;</span></span>
<span class="line"><span style="color:#24292e;">        // 3. 反射调用Catalina的setParentClassLoader方法，将sharedLoader设置为</span></span>
<span class="line"><span style="color:#24292e;">Catalina的parentClassLoader成员变量</span></span>
<span class="line"><span style="color:#24292e;">        Method method =</span></span>
<span class="line"><span style="color:#24292e;">                startupInstance.getClass().getMethod(methodName, paramTypes);</span></span>
<span class="line"><span style="color:#24292e;">        method.invoke(startupInstance, paramValues);</span></span>
<span class="line"><span style="color:#24292e;">        //4、将catalina实例赋值</span></span>
<span class="line"><span style="color:#24292e;">        catalinaDaemon = startupInstance;</span></span>
<span class="line"><span style="color:#24292e;">    }</span></span></code></pre></div><h3 id="catalina-load" tabindex="-1"><code>Catalina#load();</code> <a class="header-anchor" href="#catalina-load" aria-label="Permalink to &quot;\`Catalina#load();\`&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">org.apache.catalina.startup.Bootstrap#main中的load方法调用的是catalina中的方法</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">org.apache.catalina.startup.Bootstrap#main中的load方法调用的是catalina中的方法</span></span></code></pre></div><h4 id="_1-load初始化流程" tabindex="-1">1）load初始化流程 <a class="header-anchor" href="#_1-load初始化流程" aria-label="Permalink to &quot;1）load初始化流程&quot;">​</a></h4><p>模板模式：</p><p>每个节点自己完成的任务后，会接着调用子节点（如果有的话）的同样的方法，引起链式反应。</p><p><img src="`+_a+'" alt="image-20220707102653576"></p><h3 id="catalina-start" tabindex="-1"><code>Catalina#start();</code> <a class="header-anchor" href="#catalina-start" aria-label="Permalink to &quot;`Catalina#start();`&quot;">​</a></h3><p><strong>流程图</strong></p><p>与load过程很相似</p><p><img src="'+xa+'" alt="image-20220707102718169"></p><h2 id="流程分析-servlet请求处理链路跟踪" tabindex="-1">流程分析-Servlet请求处理链路跟踪 <a class="header-anchor" href="#流程分析-servlet请求处理链路跟踪" aria-label="Permalink to &quot;流程分析-Servlet请求处理链路跟踪&quot;">​</a></h2><p>问题：设计了这么多层次的容器，Tomcat 是怎么确定请求是由哪个 Wrapper 容器里的 Servlet 来处理的呢？答案是，Tomcat 是用 Mapper 组件来完成这个任务的。</p><p>Mapper 组件的功能就是将用户请求的 URL 定位到一个 Servlet，它的工作原理是：Mapper 组件里保存了 Web 应用的配置信息，其实就是容器组件与访问路径的映射关系，比如 Host 容器里配置的域名、Context 容器里的 Web 应用路径，以及 Wrapper 容器里 Servlet 映射的路径，你可以想象这些配置信息就是一个多层次的 Map。</p><p>当一个请求到来时，Mapper 组件通过解析请求 URL 里的域名和路径，再到自己保存的 Map 里去查找，就能定位到一个 Servlet。请你注意，一个请求 URL 最后只会定位到一个 Wrapper 容器，也就是一个 Servlet。</p><p>例子:</p><p><img src="'+Sa+`" alt="image-20220707102749389"></p><p>假如有用户访问一个 URL，比如图中的<code>http://user.shopping.com:8080/order/buy</code>，Tomcat 如何将这个 URL 定位到一个 Servlet 呢？</p><p>**首先，**根据协议和端口号选定 Service 和 Engine。</p><p>我们知道 Tomcat 的每个连接器都监听不同的端口，比如 Tomcat 默认的 HTTP 连接器监听 8080 端口、默认的 AJP 连接器监听 8009 端口。上面例子中的 URL 访问的是 8080 端口，因此这个请求会被 HTTP 连接器接收，而一个连接器是属于一个 Service 组件的，这样 Service 组件就确定了。我们还知道一个 Service 组件里除了有多个连接器，还有一个容器组件，具体来说就是一个 Engine 容器，因此 Service 确定了也就意味着 Engine 也确定了。</p><p>**然后，**根据域名选定 Host。 Service 和 Engine 确定后，Mapper 组件通过 URL 中的域名去查找相应的 Host 容器，比如例子中的 URL 访问的域名是user.shopping.com，因此 Mapper 会找到 Host2 这个容器。</p><p>**之后，**根据 URL 路径找到 Context 组件。</p><p>Host 确定以后，Mapper 根据 URL 的路径来匹配相应的 Web 应用的路径，比如例子中访问的是/order，因此找到了 Context4 这个 Context 容器。</p><p>**最后，**根据 URL 路径找到 Wrapper（Servlet）。 Context 确定后，Mapper 再根据web.xml中配置的 Servlet 映射路径来找到具体的 Wrapper 和 Servlet。</p><p>我们知道容器组件最重要的功能是处理请求，最先拿到请求的是 Engine 容器，Engine 容器对请求做一些处理后，会把请求传给自己子容器 Host 继续处理，依次类推，最后这个请求会传给 Wrapper 容器，Wrapper 会调用最终的 Servlet 来处理。那么这个调用过程具体是怎么实现的呢？答案是使用 Pipeline-Valve 管道。</p><p>Pipeline-Valve 是责任链模式，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将再调用下一个处理者继续处理。Valve 表示一个处理点，比如权限认证和记录日志。如果还不太理解的话，可以来看看 Valve 和 Pipeline 接口中的关键方法</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">public interface Valve {</span></span>
<span class="line"><span style="color:#e1e4e8;">  public Valve getNext();</span></span>
<span class="line"><span style="color:#e1e4e8;">  public void setNext(Valve valve);</span></span>
<span class="line"><span style="color:#e1e4e8;">  public void invoke(Request request, Response response)</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">public interface Valve {</span></span>
<span class="line"><span style="color:#24292e;">  public Valve getNext();</span></span>
<span class="line"><span style="color:#24292e;">  public void setNext(Valve valve);</span></span>
<span class="line"><span style="color:#24292e;">  public void invoke(Request request, Response response)</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><p>由于 Valve 是一个处理点，因此 invoke 方法就是来处理请求的。注意到 Valve 中有 getNext 和 setNext 方法，因此我们大概可以猜到有一个链表将 Valve 链起来了。请你继续看 Pipeline 接口：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">public interface Pipeline extends Contained {</span></span>
<span class="line"><span style="color:#e1e4e8;">  public void addValve(Valve valve);</span></span>
<span class="line"><span style="color:#e1e4e8;">  public Valve getBasic();</span></span>
<span class="line"><span style="color:#e1e4e8;">  public void setBasic(Valve valve);</span></span>
<span class="line"><span style="color:#e1e4e8;">  public Valve getFirst();</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">public interface Pipeline extends Contained {</span></span>
<span class="line"><span style="color:#24292e;">  public void addValve(Valve valve);</span></span>
<span class="line"><span style="color:#24292e;">  public Valve getBasic();</span></span>
<span class="line"><span style="color:#24292e;">  public void setBasic(Valve valve);</span></span>
<span class="line"><span style="color:#24292e;">  public Valve getFirst();</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><p>没错，Pipeline 中有 addValve 方法。Pipeline 中维护了 Valve 链表，Valve 可以插入到 Pipeline 中，对请求做某些处理。我们还发现 Pipeline 中没有 invoke 方法，因为整个调用链的触发是 Valve 来完成的，Valve 完成自己的处理后，调用getNext.invoke来触发下一个 Valve 调用。</p><p>每一个容器都有一个 Pipeline 对象，只要触发这个 Pipeline 的第一个 Valve，这个容器里 Pipeline 中的 Valve 就都会被调用到。但是，不同容器的 Pipeline 是怎么链式触发的呢，比如 Engine 中 Pipeline 需要调用下层容器 Host 中的 Pipeline</p><p>这是因为 Pipeline 中还有个 getBasic 方法。这个 BasicValve 处于 Valve 链表的末端，它是 Pipeline 中必不可少的一个 Valve，负责调用下层容器的 Pipeline 里的第一个 Valve。还是通过一张图来解释</p><p><img src="`+Ea+`" alt="image-20220707102922853"></p><p>每一个容器组件都有一个 Pipeline，而 Pipeline 中有一个基础阀（Basic Valve），而 Engine 容器的基础阀定义如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">final class StandardEngineValve extends ValveBase {</span></span>
<span class="line"><span style="color:#e1e4e8;">    public final void invoke(Request request, Response response)</span></span>
<span class="line"><span style="color:#e1e4e8;">      throws IOException, ServletException {</span></span>
<span class="line"><span style="color:#e1e4e8;">  </span></span>
<span class="line"><span style="color:#e1e4e8;">      //拿到请求中的Host容器</span></span>
<span class="line"><span style="color:#e1e4e8;">      Host host = request.getHost();</span></span>
<span class="line"><span style="color:#e1e4e8;">      if (host == null) {</span></span>
<span class="line"><span style="color:#e1e4e8;">          return;</span></span>
<span class="line"><span style="color:#e1e4e8;">      }</span></span>
<span class="line"><span style="color:#e1e4e8;">  </span></span>
<span class="line"><span style="color:#e1e4e8;">      // 调用Host容器中的Pipeline中的第一个Valve</span></span>
<span class="line"><span style="color:#e1e4e8;">      host.getPipeline().getFirst().invoke(request, response);</span></span>
<span class="line"><span style="color:#e1e4e8;">  }</span></span>
<span class="line"><span style="color:#e1e4e8;"> j</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">final class StandardEngineValve extends ValveBase {</span></span>
<span class="line"><span style="color:#24292e;">    public final void invoke(Request request, Response response)</span></span>
<span class="line"><span style="color:#24292e;">      throws IOException, ServletException {</span></span>
<span class="line"><span style="color:#24292e;">  </span></span>
<span class="line"><span style="color:#24292e;">      //拿到请求中的Host容器</span></span>
<span class="line"><span style="color:#24292e;">      Host host = request.getHost();</span></span>
<span class="line"><span style="color:#24292e;">      if (host == null) {</span></span>
<span class="line"><span style="color:#24292e;">          return;</span></span>
<span class="line"><span style="color:#24292e;">      }</span></span>
<span class="line"><span style="color:#24292e;">  </span></span>
<span class="line"><span style="color:#24292e;">      // 调用Host容器中的Pipeline中的第一个Valve</span></span>
<span class="line"><span style="color:#24292e;">      host.getPipeline().getFirst().invoke(request, response);</span></span>
<span class="line"><span style="color:#24292e;">  }</span></span>
<span class="line"><span style="color:#24292e;"> j</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><p>这个基础阀实现非常简单，就是把请求转发到 Host 容器。问题是处理请求的 Host 容器对象是从请求中拿到的，请求对象中怎么会有 Host 容器呢？这是因为请求到达 Engine 容器中之前，Mapper 组件已经对请求进行了路由处理，Mapper 组件通过请求的 URL 定位了相应的容器，并且把容器对象保存到了请求对象中。</p>`,409),wa=[Aa];function La(Ha,Ra,Ba,Wa,Ma,ja){return s(),e("div",null,wa)}const Va=a(Ia,[["render",La]]);export{Oa as __pageData,Va as default};
