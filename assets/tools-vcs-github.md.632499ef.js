import{_ as s,o as a,c as n,Q as p}from"./chunks/framework.027d2da0.js";const o="/images/image-20230915150341031.png",e="/images/image-20230915150344792.png",l="/images/image-20230915150350092.png",t="/images/image-20230915150354142.png",c="/images/image-20230915150357896.png",i="/images/image-20230915150401488.png",r="/images/image-20230915150405755.png",g="/images/image-20230915150410169.png",d="/images/image-20230915150414310.png",h="/images/image-20230915150418284.png",y="/images/image-20230915150421808.png",m="/images/image-20230915150427106.png",E="/images/image-20230915150435127.png",u="/images/image-20230915150438571.png",b="/images/image-20230915150442739.png",_="/images/image-20230915150447548.png",A="/images/image-20230915150452555.png",k="/images/image-20230915150457369.png",q="/images/image-20230915150500918.png",D="/images/image-20230915150506798.png",F="/images/image-20230915150522494.png",S="/images/image-20230915201309973.png",f="/images/image-20230915150530462.png",C="/images/image-20230915212247133.png",P="/images/image-20230915214527181.png",O="/images/image-20230915214550158.png",R="/images/image-20230915214641975.png",T="/images/image-20230915214732699.png",x="/images/image-20230915214817809.png",$=JSON.parse('{"title":"Github","description":"","frontmatter":{"typora-root-url":"./..\\\\..\\\\..\\\\..\\\\public"},"headers":[],"relativePath":"tools-vcs-github.md","filePath":"docs/06_工具/02_版本控制/01_GIT/04_Github.md"}'),v={name:"tools-vcs-github.md"},G=p('<h1 id="github" tabindex="-1">Github <a class="header-anchor" href="#github" aria-label="Permalink to &quot;Github&quot;">​</a></h1><h2 id="ssh生成公钥私钥" tabindex="-1">ssh生成公钥私钥 <a class="header-anchor" href="#ssh生成公钥私钥" aria-label="Permalink to &quot;ssh生成公钥私钥&quot;">​</a></h2><blockquote><p>ssh-keygen -t rsa -b 4096 -C &quot;邮箱&quot;</p></blockquote><p>这条命令的目的是为了让本地机器ssh登录远程机器上的GitHub账户无需输入密码。</p><p>将这条命令分解:</p><h3 id="ssh-keygen" tabindex="-1"><strong>ssh-keygen</strong> <a class="header-anchor" href="#ssh-keygen" aria-label="Permalink to &quot;**ssh-keygen**&quot;">​</a></h3><p>SSH 为 Secure Shell 的缩写，SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。</p><p>从客户端来看，SSH提供两种级别的安全验证：</p><p>​ 第一种级别（基于口令的安全验证）：只要你知道自己帐号和口令，就可以登录到远程主机。所有传输的数据都会被加密，但是不能保证你正在连接的服务器就是你想连接的服务器。可能会有别的服务器在冒充真正的服务器，也就是受到“中间人”这种方式的攻击。</p><p>​ 第二种级别（基于密匙的安全验证）ssh-keygen：需要依靠密匙，你必须为自己创建一对密匙，并把公用密匙放在需要访问的服务器上。如果你要连接到SSH服务器上，客户端软件就会向服务器发出请求，请求用你的密匙进行安全验证。服务器收到请求之后，先在该服务器上你的主目录下寻找你的公用密匙，然后把它和你发送过来的公用密匙进行比较。如果两个密匙一致，服务器就用公用密匙加密“质询”（challenge）并把它发送给客户端软件。客户端软件收到“质询”之后就可以用你的私人密匙解密再把它发送给服务器。用这种方式，你必须知道自己密匙的口令。但是，与第一种级别相比，第二种级别不需要在网络上传送口令。第二种级别不仅加密所有传送的数据，而且“中间人”这种攻击方式也是不可能的（因为他没有你的私人密匙）。但是整个登录的过程可能需要10秒 。</p><p>​ ssh-keygen有很多的参数，比如这里的-t -b -C都是他的一些参数。</p><h3 id="t-rsa-t是type的缩写" tabindex="-1"><strong>-t rsa：t是type的缩写</strong> <a class="header-anchor" href="#t-rsa-t是type的缩写" aria-label="Permalink to &quot;**-t rsa：t是type的缩写**&quot;">​</a></h3><p><code>-t</code>即指定密钥的类型，密钥的类型有两种，一种是RSA，一种是DSA：</p><ul><li><p>RSA：RSA加密算法是一种非对称加密算法，是由三个麻省理工的牛人弄出来的，RSA是他们三个人姓的开头首字母组合。</p></li><li><p>DSA：Digital Signature Algorithm (DSA)是Schnorr和ElGamal签名算法的变种。</p></li></ul><p>为了让两个linux机器之间使用ssh不需要用户名和密码。所以采用了数字签名RSA或者DSA来完成这个操作。ssh-keygen默认使用rsa密钥，所以不加-t rsa也行，如果你想生成dsa密钥，就需要加参数-t dsa。</p><h3 id="b-4096-b是bit的缩写" tabindex="-1"><strong>-b 4096：b是bit的缩写</strong> <a class="header-anchor" href="#b-4096-b是bit的缩写" aria-label="Permalink to &quot;**-b 4096：b是bit的缩写**&quot;">​</a></h3><p><code>-b</code> 指定密钥长度。对于RSA密钥，最小要求768位，默认是2048位。命令中的4096指的是RSA密钥长度为4096位。</p><p>DSA密钥必须恰好是1024位(FIPS 186-2 标准的要求)。</p><h3 id="c-邮箱-c是comment的缩写" tabindex="-1"><strong>-C &quot;邮箱&quot;：C是comment的缩写</strong> <a class="header-anchor" href="#c-邮箱-c是comment的缩写" aria-label="Permalink to &quot;**-C &quot;邮箱&quot;：C是comment的缩写**&quot;">​</a></h3><p><code>-C</code>表示要提供一个新注释，用于识别这个密钥，所以“”里面不一定非要填邮箱，可以是任何内容，邮箱仅仅是识别用的key</p><p>总结：当你创建ssh的时候：-t 表示密钥的类型 ，-b表示密钥的长度，-C 用于识别这个密钥的注释 ，这个注释你可以输入任何内容，很多网站和软件用这个注释作为密钥的名字</p><p>推送到github</p><h2 id="idea操作git-ssh协议" tabindex="-1"><strong>idea操作git（ssh协议）</strong> <a class="header-anchor" href="#idea操作git-ssh协议" aria-label="Permalink to &quot;**idea操作git（ssh协议）**&quot;">​</a></h2><h3 id="问题" tabindex="-1"><strong>问题</strong> <a class="header-anchor" href="#问题" aria-label="Permalink to &quot;**问题**&quot;">​</a></h3><p>我们发现，使用IDEA上的git功能，当使用ssh协议出现了可以commit但无法push和pull的问题，经过测试发现原因是Could not read from remsitory。直接翻译是 “远程仓库无法读取”。</p><p><img src="'+o+'" alt="image-20230915150341031"></p><p>为什么会无法读取呢？（ssh权限问题）</p><p>1、无法链接服务器？</p><p>可是，确认是可以连上服务器的。（保证连接github服务器）</p><p>2、IDEA中git集成中使用的ssh方式问题</p><p>在网上看到，在Settings-&gt;Version Control-&gt;Git中，将SSH executable设置为Native即可，如图，红色方框中是要修改的地方。</p><p><img src="'+e+'" alt="image-20230915150344792"></p><p>在解决问题的过程中看到stackoverflow中是让更改“SSH executable” 方式为 Native，但仅仅这样是无效的。。。</p><p>3、无法通过SSH的链接验证。</p><p>所以可以通过创建ssh key 并将产生的id_rsa.pub的内容加到github的后台就可以解决问题了。</p><p>（1）产生key，在这个过程 中，可以添加“你的github账号名”</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">ssh-keygen -t rsa -C &quot;你的github帐号名或者邮箱&quot;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">ssh-keygen -t rsa -C &quot;你的github帐号名或者邮箱&quot;</span></span></code></pre></div><p>输入：ssh-keygen -t rsa -C &quot;<a href="mailto:ly@itcast.cn" target="_blank" rel="noreferrer">ly@itcast.cn</a>&quot;</p><p><img src="'+l+'" alt="image-20230915150350092"></p><p>生成过程采用默认方式，直接按enter键到生成id_rsa,id_rsa.pub</p><p>将生成的id_rsa.pub中的内容添加到相应的git服务器，需要放置到个人帐号中的仓库里。</p><p>注意：这里需要重新生成key！！！！！</p><p>（2）加key</p><p>首先创建仓库mytest_ssh</p><p><img src="'+t+'" alt="image-20230915150354142"></p><p>最后，对mytest_ssh进行可写操作，并添加公钥的key</p><p>在mytest_ssh仓库中选择settings，添加add deploy key</p><p><img src="'+c+'" alt="image-20230915150357896"></p><p>（1）：添加公钥的key</p><p>（2）：勾选允许可写操作</p><p><img src="'+i+'" alt="image-20230915150401488"></p><p>添加完成：</p><p><img src="'+r+'" alt="image-20230915150405755"></p><p>如果报错说，当前key已经存在，需要删除</p><p><img src="'+g+'" alt="image-20230915150410169"></p><h3 id="push命令" tabindex="-1">push命令 <a class="header-anchor" href="#push命令" aria-label="Permalink to &quot;push命令&quot;">​</a></h3><p>创建git_day01_demo工程，测试push到远程仓库，即可：</p><p><img src="'+d+'" alt="image-20230915150414310"></p><p>注意，在使用ieda进行SSH协议上传的时候，保证在.ssh文件中存在known_hosts文件，这样才可以进行交互，否则权限会依然不足</p><p><img src="'+h+'" alt="image-20230915150418284"></p><p>可以使用：git bush</p><p><img src="'+y+'" alt="image-20230915150421808"></p><h3 id="clone命令" tabindex="-1">clone命令 <a class="header-anchor" href="#clone命令" aria-label="Permalink to &quot;clone命令&quot;">​</a></h3><p>选择VCS---&gt;Checkout from Version Control---&gt;GitHub</p><p><img src="'+m+'" alt="image-20230915150427106"></p><p>使用ssh协议。</p><p><img src="'+E+'" alt="image-20230915150435127"></p><p>此处使用ssh形式的url，点击“test”按钮后显示连接成功。</p><p><img src="'+u+'" alt="image-20230915150438571"></p><p>点击OK按钮后根据提示将远程仓库克隆下来，然后导入到idea中。</p><p><img src="'+b+'" alt="image-20230915150442739"></p><p>这里点击“No”，我们再使用idea导入目录下的项目即可。</p><p><img src="'+_+'" alt="image-20230915150447548"></p><p>使用idea--&gt;Open</p><p><img src="'+A+'" alt="image-20230915150452555"></p><p>查看idea</p><p><img src="'+k+'" alt="image-20230915150457369"></p><h3 id="pull命令" tabindex="-1">pull命令 <a class="header-anchor" href="#pull命令" aria-label="Permalink to &quot;pull命令&quot;">​</a></h3><p><img src="'+q+'" alt="image-20230915150500918"></p><p>使用pull命令</p><p><img src="'+D+'" alt="image-20230915150506798"></p><h2 id="国内访问慢解决方法" tabindex="-1">国内访问慢解决方法 <a class="header-anchor" href="#国内访问慢解决方法" aria-label="Permalink to &quot;国内访问慢解决方法&quot;">​</a></h2><blockquote><p>最好的自然是科学上网,不用再操心了。</p></blockquote><p>原理：查询节点，将github映射到快的节点上</p><p><a href="https://github.com.ipaddress.com/" target="_blank" rel="noreferrer">https://github.com.ipaddress.com/</a></p><p><img src="'+F+'" alt="image-20230915150522494"></p><p><a href="https://fastly.net.ipaddress.com/github.global.ssl.fastly.net" target="_blank" rel="noreferrer">https://fastly.net.ipaddress.com/github.global.ssl.fastly.net</a></p><p><img src="'+S+'" alt="image-20230915201309973"></p><p><img src="'+f+'" alt="image-20230915150530462"></p><p>NB！</p><h2 id="github-actions" tabindex="-1">Github Actions <a class="header-anchor" href="#github-actions" aria-label="Permalink to &quot;Github Actions&quot;">​</a></h2><blockquote><p>比如vitepress博客的源代码不想暴露，只能接受build后的代码暴露</p></blockquote><p>有很多种解决方案</p><h3 id="gitignore" tabindex="-1">.gitignore <a class="header-anchor" href="#gitignore" aria-label="Permalink to &quot;.gitignore&quot;">​</a></h3><p>这种方式比较简单，只需要把源代码目录添加到 <code>.gitignore</code> 里就可以了，仓库里只存放打包编译过后的产物。</p><p>不过带来的问题就是源代码需要维护在本地磁盘上，如果哪天不小心 <code>rm -rf</code> 就找不回来了</p><h3 id="公开仓储-私有仓储" tabindex="-1">公开仓储 + 私有仓储 <a class="header-anchor" href="#公开仓储-私有仓储" aria-label="Permalink to &quot;公开仓储 + 私有仓储&quot;">​</a></h3><p>这种方式就是采用两个仓储，私有仓库用来存放源码，公开仓库用来存放产物。这样就解决了源代码存储在本地磁盘上的弊端。</p><p>问题就是，需要维护两个仓库，每次需要发布到线上的时候，都需要 <code>push</code> 两遍才可以</p><h3 id="公开仓储-私有仓储-github-actions" tabindex="-1">公开仓储 + 私有仓储 + Github Actions <a class="header-anchor" href="#公开仓储-私有仓储-github-actions" aria-label="Permalink to &quot;公开仓储 + 私有仓储 + Github Actions&quot;">​</a></h3><p>这种方式就是为了解决上面那种方式需要 push 两次代码的情况，借助的正式 Github Actions 的能力。原理也很简单，整体流程如下：</p><p><img src="'+C+`" alt="image-20230915212247133"></p><p>有关 Github Actions 的含义以及使用可以参考<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdocs.github.com%2Fcn%2Factions%2Fquickstart" target="_blank" rel="noreferrer">官方文档</a>，这里简明扼要的说一下具体的操作步骤。下面约定 <code>blog</code> 为公开仓库，<code>_blog</code> 为私有仓库，先在你的 <code>github</code> 上创建这两个仓库。</p><h4 id="第一步-创建-github-actions-配置文件" tabindex="-1">第一步：创建 <code>Github Actions</code> 配置文件 <a class="header-anchor" href="#第一步-创建-github-actions-配置文件" aria-label="Permalink to &quot;第一步：创建 \`Github Actions\` 配置文件&quot;">​</a></h4><p>在 <code>_blog</code> 库中添加 <code>.github/workflows</code> 目录，并在里面创建一个名为 <code>deploy.yml</code> 的新文件（名字随便起）。 然后添加如下内容到创建好的配置文件里，字段的含义如下：</p><blockquote><p>Jobs（任务）：即配置的 jobs，jobs 默认是并行运行，可以通过 needs 关键字来设置依赖的其他 jobs。</p></blockquote><blockquote><p>Steps（步骤）：即 steps，jobs 中执行的每一步，顺序执行。每个 stps 都在自己的环境上下文中运行。一个 jobs 中可以有无限个步骤。</p></blockquote><blockquote><p>Runs（操作）：并非所有步骤都会运行操作，但是操作都是在步骤中运行的。操作是具体的命令，如打印当前目录、安装依赖等。</p></blockquote><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#85E89D;">name</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">Deploy</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;"># on 定义的是执行该 Action 的时机，这里的配置是指：</span></span>
<span class="line"><span style="color:#6A737D;"># 当 main 分支的 push 事件被触发的时候执行该任务</span></span>
<span class="line"><span style="color:#79B8FF;">on</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#85E89D;">push</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#85E89D;">branches</span><span style="color:#E1E4E8;">: [</span><span style="color:#9ECBFF;">main</span><span style="color:#E1E4E8;">]</span></span>
<span class="line"><span style="color:#6A737D;"># jobs 是定义你要运行的具体任务，</span></span>
<span class="line"><span style="color:#6A737D;"># 每个 Action 可以有多个 Job</span></span>
<span class="line"><span style="color:#6A737D;"># 每个 Job 可以有多个 Step</span></span>
<span class="line"><span style="color:#6A737D;"># 每个 Step 又可以有多个 Run</span></span>
<span class="line"><span style="color:#85E89D;">jobs</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#85E89D;">build</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#85E89D;">runs-on</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">ubuntu-latest</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;"># 运行在 ubuntu 系统环境下</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#85E89D;">steps</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">      - </span><span style="color:#85E89D;">uses</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">actions/checkout@v2</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;"># uses 命令允许我们使用别人定义好的 Action，这里是从仓库检出分支</span></span>
<span class="line"><span style="color:#E1E4E8;">      - </span><span style="color:#85E89D;">uses</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">actions/setup-node@v2</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;"># 这里是设置 node 版本</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#85E89D;">with</span><span style="color:#E1E4E8;">: </span><span style="color:#6A737D;"># 这里相当于传递给上面指令的参数，告诉他使用 node@12.13.1 这个版本</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#85E89D;">node-version</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">&#39;12.13.1&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">      - </span><span style="color:#85E89D;">name</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">Install Dependencies</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;"># name 定义步骤的名称，这个可以在该 Action 运行起来之后，在 Github Actions Tab 下看到</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#85E89D;">run</span><span style="color:#E1E4E8;">: </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;"># \`run: |\` 的方式，允许我们一次定义多个要执行的命令</span></span>
<span class="line"><span style="color:#9ECBFF;">          yarn install</span></span>
<span class="line"><span style="color:#9ECBFF;">          yarn run build</span></span>
<span class="line"><span style="color:#E1E4E8;">      - </span><span style="color:#85E89D;">name</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">Push To Pages</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#85E89D;">working-directory</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">./dist</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;"># 指定下面指令运行的目录</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#85E89D;">run</span><span style="color:#E1E4E8;">: </span><span style="color:#F97583;">|</span></span>
<span class="line"><span style="color:#9ECBFF;">          git init</span></span>
<span class="line"><span style="color:#9ECBFF;">          git checkout -b main</span></span>
<span class="line"><span style="color:#9ECBFF;">          git add -A</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;"># 这里把下面所有 \`&lt;YOUR_NAME&gt;/&lt;YOUR_EMAIL&gt;/&lt;COMMIT_MSG&gt;/&lt;YOUR_TOKEN&gt;\` 替换成你自己的就可以了</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#9ECBFF;">git -c user.name=&#39;&lt;YOUR_NAME&gt;&#39; -c user.email=&#39;&lt;YOUR_EMAIL&gt;&#39; commit -m &#39;&lt;COMMIT_MSG&gt;&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;"># 这里需要一个 共开仓库 的 secrets 配置，这里的 secrets 是一个环境变量，可以直接拿过来直接用</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#9ECBFF;">git remote add origin https://&lt;YOUR_NAME&gt;:\${{secrets.&lt;YOUR_TOKEN&gt;}}@github.com/&lt;YOUR_NAME&gt;/blog.git</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#9ECBFF;">git push origin main -f -q</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#22863A;">name</span><span style="color:#24292E;">: </span><span style="color:#032F62;">Deploy</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;"># on 定义的是执行该 Action 的时机，这里的配置是指：</span></span>
<span class="line"><span style="color:#6A737D;"># 当 main 分支的 push 事件被触发的时候执行该任务</span></span>
<span class="line"><span style="color:#005CC5;">on</span><span style="color:#24292E;">:</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#22863A;">push</span><span style="color:#24292E;">:</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#22863A;">branches</span><span style="color:#24292E;">: [</span><span style="color:#032F62;">main</span><span style="color:#24292E;">]</span></span>
<span class="line"><span style="color:#6A737D;"># jobs 是定义你要运行的具体任务，</span></span>
<span class="line"><span style="color:#6A737D;"># 每个 Action 可以有多个 Job</span></span>
<span class="line"><span style="color:#6A737D;"># 每个 Job 可以有多个 Step</span></span>
<span class="line"><span style="color:#6A737D;"># 每个 Step 又可以有多个 Run</span></span>
<span class="line"><span style="color:#22863A;">jobs</span><span style="color:#24292E;">:</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#22863A;">build</span><span style="color:#24292E;">:</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#22863A;">runs-on</span><span style="color:#24292E;">: </span><span style="color:#032F62;">ubuntu-latest</span><span style="color:#24292E;"> </span><span style="color:#6A737D;"># 运行在 ubuntu 系统环境下</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#22863A;">steps</span><span style="color:#24292E;">:</span></span>
<span class="line"><span style="color:#24292E;">      - </span><span style="color:#22863A;">uses</span><span style="color:#24292E;">: </span><span style="color:#032F62;">actions/checkout@v2</span><span style="color:#24292E;"> </span><span style="color:#6A737D;"># uses 命令允许我们使用别人定义好的 Action，这里是从仓库检出分支</span></span>
<span class="line"><span style="color:#24292E;">      - </span><span style="color:#22863A;">uses</span><span style="color:#24292E;">: </span><span style="color:#032F62;">actions/setup-node@v2</span><span style="color:#24292E;"> </span><span style="color:#6A737D;"># 这里是设置 node 版本</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#22863A;">with</span><span style="color:#24292E;">: </span><span style="color:#6A737D;"># 这里相当于传递给上面指令的参数，告诉他使用 node@12.13.1 这个版本</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#22863A;">node-version</span><span style="color:#24292E;">: </span><span style="color:#032F62;">&#39;12.13.1&#39;</span></span>
<span class="line"><span style="color:#24292E;">      - </span><span style="color:#22863A;">name</span><span style="color:#24292E;">: </span><span style="color:#032F62;">Install Dependencies</span><span style="color:#24292E;"> </span><span style="color:#6A737D;"># name 定义步骤的名称，这个可以在该 Action 运行起来之后，在 Github Actions Tab 下看到</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#22863A;">run</span><span style="color:#24292E;">: </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#6A737D;"># \`run: |\` 的方式，允许我们一次定义多个要执行的命令</span></span>
<span class="line"><span style="color:#032F62;">          yarn install</span></span>
<span class="line"><span style="color:#032F62;">          yarn run build</span></span>
<span class="line"><span style="color:#24292E;">      - </span><span style="color:#22863A;">name</span><span style="color:#24292E;">: </span><span style="color:#032F62;">Push To Pages</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#22863A;">working-directory</span><span style="color:#24292E;">: </span><span style="color:#032F62;">./dist</span><span style="color:#24292E;"> </span><span style="color:#6A737D;"># 指定下面指令运行的目录</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#22863A;">run</span><span style="color:#24292E;">: </span><span style="color:#D73A49;">|</span></span>
<span class="line"><span style="color:#032F62;">          git init</span></span>
<span class="line"><span style="color:#032F62;">          git checkout -b main</span></span>
<span class="line"><span style="color:#032F62;">          git add -A</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;"># 这里把下面所有 \`&lt;YOUR_NAME&gt;/&lt;YOUR_EMAIL&gt;/&lt;COMMIT_MSG&gt;/&lt;YOUR_TOKEN&gt;\` 替换成你自己的就可以了</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#032F62;">git -c user.name=&#39;&lt;YOUR_NAME&gt;&#39; -c user.email=&#39;&lt;YOUR_EMAIL&gt;&#39; commit -m &#39;&lt;COMMIT_MSG&gt;&#39;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;"># 这里需要一个 共开仓库 的 secrets 配置，这里的 secrets 是一个环境变量，可以直接拿过来直接用</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#032F62;">git remote add origin https://&lt;YOUR_NAME&gt;:\${{secrets.&lt;YOUR_TOKEN&gt;}}@github.com/&lt;YOUR_NAME&gt;/blog.git</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#032F62;">git push origin main -f -q</span></span></code></pre></div><h4 id="第二步-添加授权" tabindex="-1">第二步：添加授权 <a class="header-anchor" href="#第二步-添加授权" aria-label="Permalink to &quot;第二步：添加授权&quot;">​</a></h4><p>因为 <code>Action</code> 是运行在可以理解为容器内部的，所以并没有向你的仓库推送代码的权限。所以就需要一种授权机制，让其可以向你的 <code>blog</code> 仓库推送构建产物。</p><p>之前 <code>Github</code> 是可以通过 <code>https://\${user.name}:\${user.password}@github.com/&lt;YOUR_NAME&gt;/blog.git</code> 这种<code>用户名 + 密码</code>的方式往仓库 <code>push</code> 代码的。但是这种方式不够灵活，后面就换成了使用 <code>Personal Token</code> 的方式了。</p><p>ok，现在我们需要从私有的 <code>_blog</code> 仓库向公开的 <code>blog</code> 仓库 <code>push</code> 代码，那么就需要 <code>_blog</code> 仓库向 <code>blog</code> 仓库进行授权，授权过程主要分为两步</p><h5 id="创建-personal-token" tabindex="-1">创建 Personal Token <a class="header-anchor" href="#创建-personal-token" aria-label="Permalink to &quot;创建 Personal Token&quot;">​</a></h5><p>当前的 <code>CI</code> 运行在 <code>blog</code> 仓库，但是需要往 <code>_blog</code> 仓库做一些事情，那么你就需要 <code>_blog</code> 仓库的管理员生成的 <code>Personal Token</code>，然后分配适当权限即可。这个 <code>Token</code> 的生成步骤如下，创建的时候一定记住了，确认之后就看不到了，不过可以重新生成。</p><p><img src="`+P+'" alt="image-20230915214527181"></p><ul><li>红框里的内容是 <code>授权信息</code> 以及 <code>token 过期时间</code> 配置</li></ul><p><img src="'+O+'" alt="image-20230915214550158"></p><h5 id="创建-secrets" tabindex="-1">创建 secrets <a class="header-anchor" href="#创建-secrets" aria-label="Permalink to &quot;创建 secrets&quot;">​</a></h5><p>这一步主要是为了加密 <code>Personal Token</code>，毕竟不能把这种东西直接放到配置文件中。</p><p>下面就在 <code>_blog</code> 仓库创建一个 <code>secrets token</code>，创建的方式也很简单，如下：</p><ul><li>找到 <code>_blog</code> 仓库下的 <code>setting</code> Tab，然后点击进入到 <code>secrets</code> 配置</li></ul><p><img src="'+R+'" alt="image-20230915214641975"></p><ul><li>起一个名字，这个名字就是上面 CI 流程里的 <code>&lt;YOUR_TOKEN&gt;</code>，然后将上一步生成的 <code>Personal Token</code> 填进去，点击添加就行了</li></ul><p><img src="'+T+'" alt="image-20230915214732699"></p><p>这样就算是完成了，下面就修改下代码，<code>push</code> 到你的公开仓库 <code>blog</code> 上试一下吧，记得是推送 <code>main</code> 分支</p><h4 id="第三步-运行" tabindex="-1">第三步：运行 <a class="header-anchor" href="#第三步-运行" aria-label="Permalink to &quot;第三步：运行&quot;">​</a></h4><p>如果一切正常，<code>Actions</code> Tab 下面就能看到构建信息，点进去可以查看详情，红框里的内容就是在 <code>deploy.yml</code> 文件中配置的步骤名称，每个步骤都可以点进去看详情，如果失败了会有失败日志</p><p><img src="'+x+'" alt="image-20230915214817809"></p><p>将blog设置为github page，加上DNS解析域名，就可以通过域名访问了。</p>',130),M=[G];function N(B,I,U,Y,H,j){return a(),n("div",null,M)}const J=s(v,[["render",N]]);export{$ as __pageData,J as default};
